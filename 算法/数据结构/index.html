
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta http-equiv="x-dns-prefetch-control" content="on">
      <link rel="dns-prefetch" href="//Jacy.org">
      <link rel="dns-prefetch" href="//search.Jacy.org">
      <link rel="dns-prefetch" href="//api.github.com">
      <link rel="dns-prefetch" href="//www.google-analytics.com">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Jacy的个人博客，总结有SLAM、视觉、算法以及数学知识的学习笔记">
      
      
        <meta name="author" content="Jacy">
      
      
        <link rel="canonical" href="http://www.jacycoder.com/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
      
      <link rel="icon" href="../../favicon.ico">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-8.5.11">
    
    
      
        <title>绪论 - jacycoder_blog</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.d9cc33f8.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.2505c338.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans:300,300i,400,400i,700,700i%7CFira+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Fira Sans";--md-code-font:"Fira Mono"}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:300;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:italic;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot);src:local('Fira Sans'),local('FiraSans-Italic'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Sans';font-style:normal;font-weight:700;src:url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot);src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.svg#FiraSans) format('svg')}@font-face{font-family:'Fira Mono';font-style:normal;font-weight:regular;src:url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot);src:local('Fira Mono'),local('FiraMono-Normal'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.svg#FiraMono) format('svg')}</style>
      
    
    
      <link rel="stylesheet" href="../../_static/css/extra.css?v=14">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  


  <script id="__analytics">function __md_analytics(){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-124485594-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){var e;this.value&&(e=document.location.pathname,ga("send","pageview",e+"?q="+this.value))}),document$.subscribe(function(){var a=document.forms.feedback;if(void 0!==a)for(var e of a.querySelectorAll("[type=submit]"))e.addEventListener("click",function(e){e.preventDefault();var t=document.location.pathname,e=this.getAttribute("data-md-value");ga("send","event","feedback","click",t,e),a.firstElementChild.disabled=!0;e=a.querySelector(".md-feedback__note [data-md-value='"+e+"']");e&&(e.hidden=!1)}),a.hidden=!1}),location$.subscribe(function(e){ga("send","pageview",e.pathname)})});var e=document.createElement("script");e.async=!0,e.src="https://www.google-analytics.com/analytics.js",document.getElementById("__analytics").insertAdjacentElement("afterEnd",e)}</script>

  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="red">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#绪论" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="jacycoder_blog" class="md-header__button md-logo" aria-label="jacycoder_blog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3 1 9l11 6 9-4.91V17h2V9M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            jacycoder_blog
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              绪论
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="red"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22Z"/></svg>
            </label>
          
        
          
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../.." class="md-tabs__link">
      Home
    </a>
  </li>

      
        
  
  


  
  
  
    <li class="md-tabs__item">
      <a href="../../%E9%A1%B9%E7%9B%AE/" class="md-tabs__link">
        项目研究
      </a>
    </li>
  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/01_2D%E5%B0%84%E5%BD%B1%E5%87%A0%E4%BD%95%E4%B8%8E%E5%8F%98%E6%8D%A2/" class="md-tabs__link">
        SLAM
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="01_%E7%BB%AA%E8%AE%BA/" class="md-tabs__link">
        算法
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/01_%E5%9F%BA%E7%A1%80%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/" class="md-tabs__link">
        数学知识
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="md-tabs__link">
        计算机基础
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/01_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="md-tabs__link">
        图像处理
      </a>
    </li>
  

  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="jacycoder_blog" class="md-nav__button md-logo" aria-label="jacycoder_blog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3 1 9l11 6 9-4.91V17h2V9M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82Z"/></svg>

    </a>
    jacycoder_blog
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          项目研究
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="项目研究" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          项目研究
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E9%A1%B9%E7%9B%AE/" class="md-nav__link">
        项目研究
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E9%A1%B9%E7%9B%AE/%E5%AE%B6%E6%94%BF%E6%9C%8D%E5%8A%A1%E6%9C%BA%E5%99%A8%E4%BA%BA/" class="md-nav__link">
        家政服务机器人
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E9%A1%B9%E7%9B%AE/%E6%9C%9D%E9%97%BB%E9%81%93%E6%9C%BA%E6%A2%B0%E8%87%82/" class="md-nav__link">
        朝闻道机械臂
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E9%A1%B9%E7%9B%AE/CO-DENSE/" class="md-nav__link">
        CO-DENSE集群无人机稠密见图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E9%A1%B9%E7%9B%AE/UWB%E9%94%9A%E7%82%B9%E8%BE%85%E5%8A%A9VIO%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D/" class="md-nav__link">
        UWB定位辅助VIO融合定位
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          SLAM
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="SLAM" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          SLAM
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_1" type="checkbox" id="__nav_3_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3_1">
          多视图几何
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="多视图几何" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_1">
          <span class="md-nav__icon md-icon"></span>
          多视图几何
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/01_2D%E5%B0%84%E5%BD%B1%E5%87%A0%E4%BD%95%E4%B8%8E%E5%8F%98%E6%8D%A2/" class="md-nav__link">
        2D射影几何与变换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/02_3D%E5%B0%84%E5%BD%B1%E5%87%A0%E4%BD%95%E4%B8%8E%E5%8F%98%E6%8D%A2/" class="md-nav__link">
        3D射影几何与变换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/03_%E4%BC%B0%E8%AE%A1%E2%80%942D%E5%B0%84%E5%BD%B1%E5%8F%98%E6%8D%A2/" class="md-nav__link">
        估计—2D射影变换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/04_%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E5%92%8C%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90/" class="md-nav__link">
        算法评价和误差分析
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/05_%E6%91%84%E5%83%8F%E6%9C%BA%E6%A8%A1%E5%9E%8B/" class="md-nav__link">
        摄像机模型
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/06_%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5%24P%24%E7%9A%84%E8%AE%A1%E7%AE%97/" class="md-nav__link">
        摄像机矩阵$P$的计算
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/07_%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA%E5%8D%95%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/" class="md-nav__link">
        进一步讨论单视图几何
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/08_%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5/" class="md-nav__link">
        对极几何和基本矩阵
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/09_%E6%91%84%E5%83%8F%E6%9C%BA%E5%92%8C%E7%BB%93%E6%9E%84%E7%9A%843D%E9%87%8D%E6%9E%84/" class="md-nav__link">
        摄像机和结构的3D重构
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/10_%E5%9F%BA%E6%9C%AC%E7%9F%A9%E9%98%B5F%E7%9A%84%E8%AE%A1%E7%AE%97/" class="md-nav__link">
        基本矩阵F的计算
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/11_%E7%BB%93%E6%9E%84%E8%AE%A1%E7%AE%97/" class="md-nav__link">
        结构计算
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/12_%E5%9C%BA%E6%99%AF%E5%B9%B3%E9%9D%A2%E5%92%8C%E5%8D%95%E5%BA%94/" class="md-nav__link">
        场景平面和单应
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%87%A0%E4%BD%95/13_%E4%BB%BF%E5%B0%84%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/" class="md-nav__link">
        仿射对极几何
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_3_2" type="checkbox" id="__nav_3_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_3_2">
          视觉SLAM
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="视觉SLAM" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_2">
          <span class="md-nav__icon md-icon"></span>
          视觉SLAM
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/01_%E4%B8%89%E7%BB%B4%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/" class="md-nav__link">
        三维刚体运动
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/02_%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/" class="md-nav__link">
        李群与李代数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/03_%E7%9B%B8%E6%9C%BA%E4%B8%8E%E5%9B%BE%E5%83%8F/" class="md-nav__link">
        相机与图像
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/04_%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/" class="md-nav__link">
        非线性优化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/05_%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/" class="md-nav__link">
        视觉里程计
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/06_%E5%90%8E%E7%AB%AF/" class="md-nav__link">
        后端
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/07_%E5%9B%9E%E7%8E%AF%E6%A3%80%E6%B5%8B/" class="md-nav__link">
        回环检测
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/08_%E5%BB%BA%E5%9B%BE/" class="md-nav__link">
        建图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../SLAM/SLAM/09_%E6%89%8B%E5%86%99SLAM%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        手写SLAM系统
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          算法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="算法" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          算法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1" type="checkbox" id="__nav_4_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1">
          数据结构
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数据结构" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          数据结构
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="01_%E7%BB%AA%E8%AE%BA/" class="md-nav__link">
        绪论
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="02_%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="md-nav__link">
        线性表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="03_%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="md-nav__link">
        栈和队列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="04_%E4%B8%B2/" class="md-nav__link">
        串
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="05_%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        树与二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="06_%E5%9B%BE/" class="md-nav__link">
        图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="07_%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="08_%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="09_%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6/" class="md-nav__link">
        计算几何学
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="10_NP%E5%AE%8C%E5%85%A8%E6%80%A7/" class="md-nav__link">
        NP完全性
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="11_%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/" class="md-nav__link">
        近似算法
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%AE%97%E6%B3%95/" class="md-nav__link">
        算法
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_3" type="checkbox" id="__nav_4_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_3">
          动态规划
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="动态规划" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_3">
          <span class="md-nav__icon md-icon"></span>
          动态规划
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="md-nav__link">
        动态规划
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/03_%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%E9%97%AE%E9%A2%98/" class="md-nav__link">
        矩阵连乘问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/04_%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/" class="md-nav__link">
        凸多边形最优三角剖分
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/05_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/" class="md-nav__link">
        最长公共子序列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/06_%E7%94%B5%E8%B7%AF%E5%B8%83%E7%BA%BF/" class="md-nav__link">
        电路布线
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/07_%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E9%97%AE%E9%A2%98/" class="md-nav__link">
        最大子段和问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/08_%E6%8A%95%E8%B5%84%E9%97%AE%E9%A2%98/" class="md-nav__link">
        投资问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/09_0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        0-1背包问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/10_%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="md-nav__link">
        最优二叉搜索树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/11_%E6%B5%81%E6%B0%B4%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6/" class="md-nav__link">
        流水作业调度
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/12_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/" class="md-nav__link">
        买卖股票的最佳时机含手续费
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/13_%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/" class="md-nav__link">
        最大子序和
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/14_%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA_1_%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/" class="md-nav__link">
        统计全为_1_的正方形子矩阵
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/15_%E7%A1%AC%E5%B8%81/" class="md-nav__link">
        硬币
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/16_%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/" class="md-nav__link">
        最长不下降的子序列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/17_%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/" class="md-nav__link">
        最长斐波那契序列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/18_%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/" class="md-nav__link">
        多米诺和托米诺平铺
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/19_%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/" class="md-nav__link">
        扣分后的最大得分
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/20_%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%9E%E8%B4%9F%E7%A7%AF/" class="md-nav__link">
        矩阵的最大非负积
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/21_%E7%AC%ACk%E4%B8%AA%E6%95%B0/" class="md-nav__link">
        第k个数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/22_%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="md-nav__link">
        环绕字符串中的唯一子字符串
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/23_%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%93%E8%89%B2/" class="md-nav__link">
        二叉树染色
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/24_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%81%AF%E9%A5%B0%E5%93%81/" class="md-nav__link">
        二叉树灯饰品
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/25_%E5%9C%A8%E6%A0%91%E4%B8%8A%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%90%8E%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/" class="md-nav__link">
        在树上执行操作以后得到的最大分数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/26_%E5%88%86%E6%B1%A4/" class="md-nav__link">
        分汤
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/27_%E6%96%B021%E7%82%B9/" class="md-nav__link">
        新21点
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/28_%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/" class="md-nav__link">
        统计子串中的唯一字符
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/29_%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%92%E7%9A%84%E6%9C%80%E4%BD%8E%E9%9A%BE%E5%BA%A6/" class="md-nav__link">
        工作计划的最低难度
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/30_%E6%95%B0%E4%BD%8D%E6%88%90%E6%9C%AC%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/" class="md-nav__link">
        数位成本和为目标值的最大数字
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/31_%E5%A0%86%E5%8F%A0%E9%95%BF%E6%96%B9%E4%BD%93%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/" class="md-nav__link">
        堆叠长方体的最大高度
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/32_%E7%A7%BB%E9%99%A4%E6%89%80%E6%9C%89%E8%BD%BD%E6%9C%89%E8%BF%9D%E7%A6%81%E8%B4%A7%E7%89%A9%E7%9A%84%E8%BD%A6%E5%8E%A2/" class="md-nav__link">
        移除所有载有违禁货物的车厢
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/33_%E5%AE%8C%E6%88%90%E6%AF%94%E8%B5%9B%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/" class="md-nav__link">
        完成比赛的最少时间
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/34_%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/" class="md-nav__link">
        等差数列划分
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_4" type="checkbox" id="__nav_4_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_4">
          二分查找
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="二分查找" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_4">
          <span class="md-nav__icon md-icon"></span>
          二分查找
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/01_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="md-nav__link">
        二分查找
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/03_%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8C%BA%E9%97%B4/" class="md-nav__link">
        重复出现的区间
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/04_%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E5%80%BC%E7%B4%A2%E5%BC%95/" class="md-nav__link">
        山峰数组的峰值索引
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/05_%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC_II/" class="md-nav__link">
        寻找旋转排序数组中的最小值_II
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/06_%E5%9C%A8D%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/" class="md-nav__link">
        在D天内送达包裹的能力
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/07_%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIV/" class="md-nav__link">
        打家劫舍IV
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/08_H%E6%8C%87%E6%95%B0II/" class="md-nav__link">
        H指数II
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/09_%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%95%B0%E5%AD%97/" class="md-nav__link">
        到达终点数字
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10_%E6%94%B6%E8%8B%B9%E6%9E%9C/" class="md-nav__link">
        收苹果
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_5" type="checkbox" id="__nav_4_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_5">
          分支限界法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="分支限界法" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_5">
          <span class="md-nav__icon md-icon"></span>
          分支限界法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/01_%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/" class="md-nav__link">
        分支限界法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/03_%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98/" class="md-nav__link">
        装载问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/04_0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        0-1背包问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/05_%E8%B4%A7%E9%83%8E%E6%8B%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        货郎担问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/06_%E5%B8%83%E7%BA%BF%E9%97%AE%E9%A2%98/" class="md-nav__link">
        布线问题
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_6" type="checkbox" id="__nav_4_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_6">
          分治法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="分治法" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_6">
          <span class="md-nav__icon md-icon"></span>
          分治法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/01_%E5%88%86%E6%B2%BB%E6%B3%95/" class="md-nav__link">
        分治法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/03_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/" class="md-nav__link">
        全排列问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/04_%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/" class="md-nav__link">
        整数划分问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/05_%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/" class="md-nav__link">
        汉诺塔问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/06_%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" class="md-nav__link">
        二分搜索
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/07_%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        合并排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/08_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        快速排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/09_%E6%9C%80%E6%8E%A5%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98/" class="md-nav__link">
        最接近点对问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/10_%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/" class="md-nav__link">
        棋盘覆盖问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%88%86%E6%B2%BB%E6%B3%95/11_%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0/" class="md-nav__link">
        统计有序矩阵中的负数
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_7" type="checkbox" id="__nav_4_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_7">
          高级数据结构
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="高级数据结构" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_7">
          <span class="md-nav__icon md-icon"></span>
          高级数据结构
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="md-nav__link">
        二叉搜索树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02_%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="md-nav__link">
        并查集
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03_%E5%AD%97%E5%85%B8%E6%A0%91/" class="md-nav__link">
        字典树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04_%E7%BA%BF%E6%AE%B5%E6%A0%91/" class="md-nav__link">
        线段树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" class="md-nav__link">
        树状数组
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06_%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" class="md-nav__link">
        后缀数组
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_8" type="checkbox" id="__nav_4_8" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_8">
          回溯法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="回溯法" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_8">
          <span class="md-nav__icon md-icon"></span>
          回溯法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9E%E6%BA%AF%E6%B3%95/01_%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="md-nav__link">
        回溯法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9E%E6%BA%AF%E6%B3%95/03_N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/" class="md-nav__link">
        N皇后问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9E%E6%BA%AF%E6%B3%95/04_%E8%B4%A7%E9%83%8E%E6%8B%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        货郎担问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9E%E6%BA%AF%E6%B3%95/05_%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98/" class="md-nav__link">
        装载问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9E%E6%BA%AF%E6%B3%95/06_%E6%89%B9%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/" class="md-nav__link">
        批作业调度问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9E%E6%BA%AF%E6%B3%95/07_0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        0-1背包问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9E%E6%BA%AF%E6%B3%95/08_%E6%9C%80%E5%A4%A7%E5%9B%A2%E9%97%AE%E9%A2%98/" class="md-nav__link">
        最大团问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%9B%9E%E6%BA%AF%E6%B3%95/09_%E5%9B%BE%E7%9A%84m%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/" class="md-nav__link">
        图的m着色问题
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_9" type="checkbox" id="__nav_4_9" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_9">
          记忆化搜索
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="记忆化搜索" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_9">
          <span class="md-nav__icon md-icon"></span>
          记忆化搜索
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/01_%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" class="md-nav__link">
        记忆化搜索
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/02_%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/" class="md-nav__link">
        经典例题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/03_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%97%AE%E9%A2%98/" class="md-nav__link">
        斐波那契问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/04_%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/" class="md-nav__link">
        我能赢吗
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_10" type="checkbox" id="__nav_4_10" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_10">
          技巧
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="技巧" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_10">
          <span class="md-nav__icon md-icon"></span>
          技巧
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/01_%E5%89%8D%E7%BC%80%E5%92%8C/" class="md-nav__link">
        前缀和
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/02_%E5%8F%8C%E6%8C%87%E9%92%88/" class="md-nav__link">
        双指针
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/03_%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/04_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" class="md-nav__link">
        滑动窗口
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/05_%E8%AE%A1%E6%95%B0/" class="md-nav__link">
        计数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/06_%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98/" class="md-nav__link">
        越界问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/07_%E4%BD%8D%E8%BF%90%E7%AE%97/" class="md-nav__link">
        位运算
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/08_%E9%9B%86%E5%90%88/" class="md-nav__link">
        集合
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8A%80%E5%B7%A7/09_%E5%8D%95%E8%B0%83%E6%A0%88/" class="md-nav__link">
        单调栈
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_11" type="checkbox" id="__nav_4_11" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_11">
          脑筋急转弯
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="脑筋急转弯" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_11">
          <span class="md-nav__icon md-icon"></span>
          脑筋急转弯
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/02_%E7%A7%BB%E5%8A%A8%E7%89%87%E6%AE%B5%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="md-nav__link">
        移动片段得到字符串
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF/03_%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/" class="md-nav__link">
        移动机器人
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_12" type="checkbox" id="__nav_4_12" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_12">
          深度广度优先搜索
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="深度广度优先搜索" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_12">
          <span class="md-nav__icon md-icon"></span>
          深度广度优先搜索
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/01_%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="md-nav__link">
        深度广度优先搜索
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/03_%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/" class="md-nav__link">
        树的非递归遍历
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/04_Morris%E9%81%8D%E5%8E%86/" class="md-nav__link">
        Morris遍历
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/05_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="md-nav__link">
        二叉树的最近公共祖先
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/06_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE/" class="md-nav__link">
        二叉搜索树的最小差
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/07_%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        对称二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/08_%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A5%87%E6%95%B0%E5%B1%82/" class="md-nav__link">
        反转二叉树的奇数层
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/09_%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97/" class="md-nav__link">
        删点成林
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/10_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/" class="md-nav__link">
        二叉树的直径
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/11_%E8%8A%82%E7%82%B9%E4%B8%8E%E5%85%B6%E7%A5%96%E5%85%88%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/" class="md-nav__link">
        节点与其祖先之间的最大差值
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/12_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/" class="md-nav__link">
        二叉树剪枝
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/13_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/" class="md-nav__link">
        二叉树展开为链表
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/14_%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/" class="md-nav__link">
        路径总和III
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/15_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2/" class="md-nav__link">
        二叉搜索树最近节点查询
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/16_%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="md-nav__link">
        最深叶节点的最近公共祖先
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/17_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9D%80%E8%89%B2%E6%B8%B8%E6%88%8F/" class="md-nav__link">
        二叉树着色游戏
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/18_%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/" class="md-nav__link">
        二叉树最大宽度
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/19_%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9/" class="md-nav__link">
        填充每一个节点的下一个右侧节点
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/20_%E5%85%8B%E9%9A%86%E5%9B%BE/" class="md-nav__link">
        克隆图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/21_%E6%B0%B4%E5%9F%9F%E5%A4%A7%E5%B0%8F/" class="md-nav__link">
        水域大小
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/22_%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/" class="md-nav__link">
        岛屿的周长
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/23_%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E6%95%B0%E9%87%8F/" class="md-nav__link">
        统计完全连通分量的数量
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/24_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        拓扑排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/25_%E4%BB%8E%E7%BB%99%E5%AE%9A%E5%8E%9F%E6%9D%90%E6%96%99%E4%B8%AD%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%87%BA%E7%9A%84%E8%8F%9C/" class="md-nav__link">
        从给定原材料中找出所有可以做出的菜
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/26_%E9%A2%9C%E8%89%B2%E4%BA%A4%E6%9B%BF%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" class="md-nav__link">
        颜色交替的最短路径
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/27_%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" class="md-nav__link">
        序列化与反序列化二叉树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/28_%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E7%8E%AF/" class="md-nav__link">
        图中的最短环
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_13" type="checkbox" id="__nav_4_13" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_13">
          数学
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数学" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_13">
          <span class="md-nav__icon md-icon"></span>
          数学
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E5%AD%A6/01_%E6%95%B0%E8%AE%BA/" class="md-nav__link">
        数论
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E5%AD%A6/02_%E4%BD%BF%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%8F%98%E6%88%901%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/" class="md-nav__link">
        使数组所有元素变成1的最小操作数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E5%AD%A6/03_%E9%9A%8F%E6%9C%BA%E5%8C%96/" class="md-nav__link">
        随机化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E5%AD%A6/04_%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/" class="md-nav__link">
        组合数学
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%95%B0%E5%AD%A6/05_%E6%A6%82%E7%8E%87%E4%B8%8E%E7%BB%9F%E8%AE%A1/" class="md-nav__link">
        概率与统计
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_14" type="checkbox" id="__nav_4_14" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_14">
          贪心
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="贪心" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_14">
          <span class="md-nav__icon md-icon"></span>
          贪心
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/01_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="md-nav__link">
        贪心算法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/03_%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92/" class="md-nav__link">
        活动安排
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/04_%E6%9C%80%E4%BC%98%E8%A3%85%E8%BD%BD/" class="md-nav__link">
        最优装载
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/05_%E6%9C%80%E4%BC%98%E5%89%8D%E7%BC%80%E7%A0%81%5B%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%5D/" class="md-nav__link">
        最优前缀码[哈夫曼编码]
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/06_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" class="md-nav__link">
        最小生成树
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/07_%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" class="md-nav__link">
        单源最短路径
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/08_%E6%8B%9F%E9%98%B5%E7%90%86%E8%AE%BA/" class="md-nav__link">
        拟阵理论
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/09_%E5%8D%95%E6%9C%BA%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" class="md-nav__link">
        单机任务调度
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/10_%E5%A4%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/" class="md-nav__link">
        多级调度问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/11_%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="md-nav__link">
        分数背包问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/12_%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/" class="md-nav__link">
        不同字符的最小子序列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/13_%E6%9C%80%E5%BC%B1%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2/" class="md-nav__link">
        最弱游戏角色
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/14_%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/" class="md-nav__link">
        吃苹果的最大数目
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/15_%E9%94%80%E5%94%AE%E4%BB%B7%E5%80%BC%E5%87%8F%E5%B0%91%E7%9A%84%E9%A2%9C%E8%89%B2%E7%90%83/" class="md-nav__link">
        销售价值减少的颜色球
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/16_%E7%A0%B4%E8%A7%A3%E9%97%AF%E5%85%B3%E5%AF%86%E7%A0%81/" class="md-nav__link">
        破解闯关密码
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/17_%E5%88%A0%E9%99%A4%E6%95%B0%E5%AF%B9%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/" class="md-nav__link">
        删除数对后的最小数组长度
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/18_%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3II/" class="md-nav__link">
        青蛙过河II
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/19_%E8%93%84%E6%B0%B4/" class="md-nav__link">
        蓄水
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/20_%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/" class="md-nav__link">
        数据流中的第K大元素
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/21_%E4%BD%A0%E8%83%BD%E6%9E%84%E9%80%A0%E5%87%BA%E8%BF%9E%E7%BB%AD%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/" class="md-nav__link">
        你能构造出连续值的最大数目
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/22_%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/" class="md-nav__link">
        任务调度器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/23_%E6%9E%84%E9%80%A0%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="md-nav__link">
        构造最长的新字符串
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/24_%E4%BD%BF%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC/" class="md-nav__link">
        使所有字符相等的最小成本
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/25_%E5%9D%8F%E4%BA%86%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/" class="md-nav__link">
        坏了的计算器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/26_%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87/" class="md-nav__link">
        段式回文
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%B4%AA%E5%BF%83/27_%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E6%88%90%E5%80%BC%E4%B8%8D%E8%B6%85%E8%BF%87k%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="md-nav__link">
        将字符串分割成值不超过k的子字符串
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_15" type="checkbox" id="__nav_4_15" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_15">
          状态压缩
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="状态压缩" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_15">
          <span class="md-nav__icon md-icon"></span>
          状态压缩
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/01_%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/" class="md-nav__link">
        状态压缩
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/02_%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/" class="md-nav__link">
        经典例题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/03_%E5%88%86%E9%A5%BC%E5%B9%B2/" class="md-nav__link">
        分饼干
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/04_%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/" class="md-nav__link">
        优美的排列
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/05_%E5%8D%9A%E5%BC%88%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/" class="md-nav__link">
        博弈状态压缩
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          数学知识
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数学知识" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          数学知识
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_1" type="checkbox" id="__nav_5_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5_1">
          高等公式
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="高等公式" data-md-level="2">
        <label class="md-nav__title" for="__nav_5_1">
          <span class="md-nav__icon md-icon"></span>
          高等公式
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/01_%E5%9F%BA%E7%A1%80%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/" class="md-nav__link">
        基础预备知识
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/02_%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/" class="md-nav__link">
        泰勒公式
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/03_%E5%B8%B8%E7%94%A8%E6%97%A0%E7%A9%B7%E5%B0%8F/" class="md-nav__link">
        常用无穷小
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/04_%E5%9F%BA%E6%9C%AC%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F/" class="md-nav__link">
        基本求导公式
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/05_%E9%AB%98%E9%98%B6%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F/" class="md-nav__link">
        高阶求导公式
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/06_%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/" class="md-nav__link">
        中值定理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/07_%E5%B8%B8%E8%A7%81%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0/" class="md-nav__link">
        常见辅助函数构造
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/08_%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/" class="md-nav__link">
        不定积分公式
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/09_%E5%AE%9A%E7%A7%AF%E5%88%86%E5%85%AC%E5%BC%8F/" class="md-nav__link">
        定积分公式
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/10_%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E7%A7%AF%E5%88%86%E5%AD%A6%E5%BA%94%E7%94%A8/" class="md-nav__link">
        一元函数微分积分学应用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/11_%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E8%AE%A1%E7%AE%97%E6%B3%95/" class="md-nav__link">
        二重积分计算法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/12_%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E6%B1%82%E8%A7%A3/" class="md-nav__link">
        常微分方程的求解
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/13_%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0%E6%94%B6%E6%95%9B%E6%80%A7%E5%88%A4%E6%96%AD/" class="md-nav__link">
        无穷级数收敛性判断
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/14_%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/" class="md-nav__link">
        傅里叶级数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/15_%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="md-nav__link">
        多元函数积分学基础知识
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/16_%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86/" class="md-nav__link">
        三重积分
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_2" type="checkbox" id="__nav_5_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5_2">
          概率论
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="概率论" data-md-level="2">
        <label class="md-nav__title" for="__nav_5_2">
          <span class="md-nav__icon md-icon"></span>
          概率论
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA/01_%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/" class="md-nav__link">
        随机事件与概率
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA/02_%E4%B8%80%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/" class="md-nav__link">
        一维随机变量及其分布
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA/03_%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/" class="md-nav__link">
        多维随机变量及其分布
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA/04_%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/" class="md-nav__link">
        随机变量的数字特征
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA/05_%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/" class="md-nav__link">
        大数定理与中心极限定理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA/06_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" class="md-nav__link">
        数理统计
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_3" type="checkbox" id="__nav_5_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5_3">
          线性代数
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="线性代数" data-md-level="2">
        <label class="md-nav__title" for="__nav_5_3">
          <span class="md-nav__icon md-icon"></span>
          线性代数
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/01_%E8%A1%8C%E5%88%97%E5%BC%8F/" class="md-nav__link">
        行列式
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/02_%E7%9F%A9%E9%98%B5/" class="md-nav__link">
        矩阵
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/03_%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/" class="md-nav__link">
        线性方程组
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/04_%E5%90%91%E9%87%8F%E7%BB%84/" class="md-nav__link">
        向量组
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/05_%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/" class="md-nav__link">
        特征值与特征向量
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/06_%E4%BA%8C%E6%AC%A1%E5%9E%8B/" class="md-nav__link">
        二次型
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_4" type="checkbox" id="__nav_5_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5_4">
          矩阵论
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="矩阵论" data-md-level="2">
        <label class="md-nav__title" for="__nav_5_4">
          <span class="md-nav__icon md-icon"></span>
          矩阵论
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%BA/01_%E7%9F%A9%E9%98%B5%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%8F%98%E6%8D%A2/" class="md-nav__link">
        矩阵的相似变换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%BA/02_%E8%8C%83%E6%95%B0%E7%90%86%E8%AE%BA/" class="md-nav__link">
        范数理论
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%BA/03_%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/" class="md-nav__link">
        矩阵分析
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%BA/04_%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/" class="md-nav__link">
        矩阵分解
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%BA/05_%E7%89%B9%E5%BE%81%E5%80%BC%E7%9A%84%E4%BC%B0%E8%AE%A1%E4%B8%8E%E8%A1%A8%E7%A4%BA/" class="md-nav__link">
        特征值的估计与表示
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%BA/06_%E5%B9%BF%E4%B9%89%E9%80%86%E7%9F%A9%E9%98%B5/" class="md-nav__link">
        广义逆矩阵
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%BA/07_%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%98%E7%A7%AF/" class="md-nav__link">
        矩阵的特殊乘积
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%9F%A9%E9%98%B5%E8%AE%BA/08_%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/" class="md-nav__link">
        线性空间与线性变换
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_5" type="checkbox" id="__nav_5_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5_5">
          数值分析
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数值分析" data-md-level="2">
        <label class="md-nav__title" for="__nav_5_5">
          <span class="md-nav__icon md-icon"></span>
          数值分析
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/01_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="md-nav__link">
        基础知识
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/02_%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9/" class="md-nav__link">
        非线性方程求根
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/03_%E8%A7%A3%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%B3%95/" class="md-nav__link">
        解线性代数方程组的直接法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/04_%E8%A7%A3%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/" class="md-nav__link">
        解线性代数方程组的迭代法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/05_%E5%87%BD%E6%95%B0%E6%8F%92%E5%80%BC/" class="md-nav__link">
        函数插值
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/06_%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%B9%B3%E6%96%B9%E9%80%BC%E8%BF%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%8B%9F%E5%90%88/" class="md-nav__link">
        函数的最佳平方逼近与数据的最小二乘拟合
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/07_%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E4%B8%8E%E6%95%B0%E5%80%BC%E5%BE%AE%E5%88%86/" class="md-nav__link">
        数值积分与数值微分
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/08_%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%9D%E5%80%BC%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E5%80%BC%E8%A7%A3%E6%B3%95/" class="md-nav__link">
        常微分方程初值问题的数值解法
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/09_%E7%9F%A9%E9%98%B5%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/" class="md-nav__link">
        矩阵特征值与特征向量的计算
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_6" type="checkbox" id="__nav_5_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5_6">
          凸优化
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="凸优化" data-md-level="2">
        <label class="md-nav__title" for="__nav_5_6">
          <span class="md-nav__icon md-icon"></span>
          凸优化
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%87%B8%E4%BC%98%E5%8C%96/01_%E5%87%B8%E9%9B%86/" class="md-nav__link">
        凸集
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E5%87%B8%E4%BC%98%E5%8C%96/02_%E5%87%B8%E5%87%BD%E6%95%B0/" class="md-nav__link">
        凸函数
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_7" type="checkbox" id="__nav_5_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_5_7">
          信息论
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="信息论" data-md-level="2">
        <label class="md-nav__title" for="__nav_5_7">
          <span class="md-nav__icon md-icon"></span>
          信息论
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/01_%E7%86%B5%E3%80%81%E7%9B%B8%E5%AF%B9%E7%86%B5%E4%B8%8E%E4%BA%92%E4%BF%A1%E6%81%AF/" class="md-nav__link">
        熵、相对熵与互信息
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/02_%E6%B8%90%E8%BF%9B%E5%9D%87%E5%88%86%E6%80%A7/" class="md-nav__link">
        渐进均分性
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/03_%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B%E7%9A%84%E7%86%B5%E7%8E%87/" class="md-nav__link">
        随机过程的熵率
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/04_%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/" class="md-nav__link">
        数据压缩
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/05_%E4%BF%A1%E9%81%93%E5%AE%B9%E9%87%8F/" class="md-nav__link">
        信道容量
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/06_%E5%BE%AE%E5%88%86%E7%86%B5/" class="md-nav__link">
        微分熵
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/07_%E9%AB%98%E6%96%AF%E4%BF%A1%E9%81%93/" class="md-nav__link">
        高斯信道
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/08_%E7%8E%87%E5%A4%B1%E7%9C%9F%E7%90%86%E8%AE%BA/" class="md-nav__link">
        率失真理论
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/09_%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BB%9F%E8%AE%A1%E5%AD%A6/" class="md-nav__link">
        信息论与统计学
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E4%BF%A1%E6%81%AF%E8%AE%BA/10_%E6%9C%80%E5%A4%A7%E7%86%B5/" class="md-nav__link">
        最大熵
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          计算机基础
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="计算机基础" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          计算机基础
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6_1" type="checkbox" id="__nav_6_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6_1">
          计算机组成原理
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="计算机组成原理" data-md-level="2">
        <label class="md-nav__title" for="__nav_6_1">
          <span class="md-nav__icon md-icon"></span>
          计算机组成原理
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="md-nav__link">
        计算机系统概述
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/02_%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/" class="md-nav__link">
        数据的表示和运算
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/03_%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        存储系统
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/04_%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        指令系统
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/05_%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="md-nav__link">
        中央处理器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/06_%E6%80%BB%E7%BA%BF/" class="md-nav__link">
        总线
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/07_%E8%BE%93%E5%85%A5_%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        输入_输出系统
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6_2" type="checkbox" id="__nav_6_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6_2">
          计算机操作系统
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="计算机操作系统" data-md-level="2">
        <label class="md-nav__title" for="__nav_6_2">
          <span class="md-nav__icon md-icon"></span>
          计算机操作系统
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="md-nav__link">
        计算机系统概述
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02_%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="md-nav__link">
        进程管理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          图像处理
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="图像处理" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          图像处理
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7_1" type="checkbox" id="__nav_7_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7_1">
          数字图像处理
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数字图像处理" data-md-level="2">
        <label class="md-nav__title" for="__nav_7_1">
          <span class="md-nav__icon md-icon"></span>
          数字图像处理
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/01_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="md-nav__link">
        基础概念
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/02_%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2/" class="md-nav__link">
        灰度变换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/03_%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/" class="md-nav__link">
        图像滤波
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/04_%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/" class="md-nav__link">
        空间滤波
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/05_%E9%A2%91%E7%8E%87%E5%9F%9F%E6%BB%A4%E6%B3%A2/" class="md-nav__link">
        频率域滤波
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/06_%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F%E4%B8%8E%E9%87%8D%E5%BB%BA/" class="md-nav__link">
        图像复原与重建
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/07_%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" class="md-nav__link">
        彩色图像处理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/08_%E5%BD%A2%E6%80%81%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" class="md-nav__link">
        形态学图像处理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/09_%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/" class="md-nav__link">
        图像分割
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/10_%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%8F%8F%E8%BF%B0/" class="md-nav__link">
        表示和描述
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/11_%E5%85%B6%E4%BB%96%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" class="md-nav__link">
        其他图像处理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#数据结构基本概念" class="md-nav__link">
    数据结构基本概念
  </a>
  
    <nav class="md-nav" aria-label="数据结构基本概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#基本概念和术语" class="md-nav__link">
    基本概念和术语
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#数据结构三要素" class="md-nav__link">
    数据结构三要素
  </a>
  
    <nav class="md-nav" aria-label="数据结构三要素">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#逻辑结构" class="md-nav__link">
    逻辑结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#存储结构" class="md-nav__link">
    存储结构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#数据的运算" class="md-nav__link">
    数据的运算
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#数据结构的扩张" class="md-nav__link">
    数据结构的扩张
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#算法和算法评价" class="md-nav__link">
    算法和算法评价
  </a>
  
    <nav class="md-nav" aria-label="算法和算法评价">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#算法的定义特性和评价标准" class="md-nav__link">
    算法的定义、特性和评价标准
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#算法效率的度量" class="md-nav__link">
    算法效率的度量
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  

<h1 id="绪论">绪论<a class="headerlink" href="#绪论" title="Permanent link">&para;</a></h1>
<h2 id="数据结构基本概念">数据结构基本概念<a class="headerlink" href="#数据结构基本概念" title="Permanent link">&para;</a></h2>
<h3 id="基本概念和术语">基本概念和术语<a class="headerlink" href="#基本概念和术语" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>术语</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据</td>
<td>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合</td>
</tr>
<tr>
<td>数据元素</td>
<td>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理，含有多个数据项</td>
</tr>
<tr>
<td>数据项</td>
<td>是构成数据元素的不可分割的最小单位</td>
</tr>
<tr>
<td>数据对象</td>
<td>具有相同性质的数据元素的集合，是数据的一个子集</td>
</tr>
<tr>
<td>数据类型</td>
<td>一个值的集合和定义在此集合上的一组操作的总称{原子类型、结构类型、抽象数据类型}</td>
</tr>
<tr>
<td>数据结构</td>
<td>相互之间存在一种或多种特定关系的数据元素的集合</td>
</tr>
</tbody>
</table>
<p><strong>数据类型</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子类型</td>
<td>其值不可再分的数据类型</td>
</tr>
<tr>
<td>结构类型</td>
<td>其值可以再分解为若干成分的数据类型</td>
</tr>
<tr>
<td>抽象数据类型ADT</td>
<td>抽象数据组织及与之相关的操作</td>
</tr>
</tbody>
</table>
<p><strong>抽象数据类型的定义格式</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">ADT</span><span class="w"> </span><span class="n">抽象数据类型名</span><span class="p">{</span><span class="c1">//抽象数据类型定义格式</span>
<span class="w">    </span><span class="nl">数据对象</span><span class="p">:</span><span class="o">&lt;</span><span class="n">数据对象的定义</span><span class="o">&gt;</span><span class="w">      </span><span class="c1">//自然语言</span>
<span class="w">    </span><span class="nl">数据关系</span><span class="p">:</span><span class="o">&lt;</span><span class="n">数据关系的定义</span><span class="o">&gt;</span><span class="w">      </span><span class="c1">//自然语言</span>
<span class="w">    </span><span class="nl">基本操作</span><span class="p">:</span><span class="o">&lt;</span><span class="n">基本操作的定义</span><span class="o">&gt;</span>
<span class="p">}</span><span class="n">ADT</span><span class="w"> </span><span class="n">抽象数据类型名</span><span class="p">;</span>

<span class="c1">//基本操作的定义格式</span>
<span class="n">基本操作名</span><span class="p">(</span><span class="n">参数表</span><span class="p">)</span><span class="w">  </span><span class="c1">//参数表中赋值参数只提供输入值，引用参数以&amp;打头，可提供输入值和返回操作结果</span>
<span class="w">    </span><span class="nl">初始条件</span><span class="p">:</span><span class="o">&lt;</span><span class="n">初始条件描述</span><span class="o">&gt;</span>
<span class="w">    </span><span class="nl">操作结果</span><span class="p">:</span><span class="o">&lt;</span><span class="n">操作结果描述</span><span class="o">&gt;</span>
</code></pre></div></td></tr></table></div>
<h3 id="数据结构三要素">数据结构三要素<a class="headerlink" href="#数据结构三要素" title="Permanent link">&para;</a></h3>
<h4 id="逻辑结构">逻辑结构<a class="headerlink" href="#逻辑结构" title="Permanent link">&para;</a></h4>
<p>定义：逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。</p>
<p>分类：</p>
<ul>
<li>线性结构：一般线性表、受限线性表（栈和队列）、线性表推广（数组）</li>
<li>非线性结构：集合结构、树结构、图结构</li>
</ul>
<h4 id="存储结构">存储结构<a class="headerlink" href="#存储结构" title="Permanent link">&para;</a></h4>
<p>定义：存储结构是指数据结构在计算机中的表示，也称物理结构</p>
<p>分类：</p>
<table>
<thead>
<tr>
<th>存储结构</th>
<th>定义</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序存储</td>
<td>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</td>
<td>随机存取，占用空间少</td>
<td>使用一整块相邻的存储单元，产生较多碎片</td>
</tr>
<tr>
<td>链式存储</td>
<td>不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</td>
<td>不会出现碎片，充分利用所有存储单元</td>
<td>需要额外空间，只能顺序存取</td>
</tr>
<tr>
<td>索引存储</td>
<td>在存储元素信息的同时，还建立附加的索引表。</td>
<td>检索速度快</td>
<td>附加的索引表需要额外空间。增删数据修改索引表时花费时间</td>
</tr>
<tr>
<td>散列存储</td>
<td>根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。</td>
<td>检索、增加和删除结点的操作很快</td>
<td>可能出现元素存储单元的冲突，解决冲突会增加时间和空间开销</td>
</tr>
</tbody>
</table>
<h4 id="数据的运算">数据的运算<a class="headerlink" href="#数据的运算" title="Permanent link">&para;</a></h4>
<p>定义：施加在数据上的运算包括运算的定义和实现。定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
<h2 id="数据结构的扩张">数据结构的扩张<a class="headerlink" href="#数据结构的扩张" title="Permanent link">&para;</a></h2>
<ol>
<li>选择一种基础数据结构</li>
<li>确定基础数据结构中要维护的附加信息</li>
<li>检验基础数据结构上的基本修改操作能否维护附加信息</li>
<li>设计一些新操作</li>
</ol>
<h2 id="算法和算法评价">算法和算法评价<a class="headerlink" href="#算法和算法评价" title="Permanent link">&para;</a></h2>
<h3 id="算法的定义特性和评价标准">算法的定义、特性和评价标准<a class="headerlink" href="#算法的定义特性和评价标准" title="Permanent link">&para;</a></h3>
<ul>
<li>定义：算法是针对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</li>
<li>特性：输入、输出、确定性、有穷性、可行性</li>
<li>评价标准</li>
<li>正确性：正确结果</li>
<li>可读性</li>
<li>健壮性：输入数据非法时，能够适当的作出反应或相应处理，不会产生莫名其妙的输出结果</li>
<li>高效性：时间和空间</li>
</ul>
<h3 id="算法效率的度量">算法效率的度量<a class="headerlink" href="#算法效率的度量" title="Permanent link">&para;</a></h3>
<ul>
<li>算法效率分为时间效率和空间效率</li>
<li>定义</li>
</ul>
<div class="arithmatex">\[
T(n)=O(f(n)),S(n)=O(g(n))
\]</div>
<ul>
<li>函数的渐进的界<span class="arithmatex">\(O(g(n))\)</span></li>
</ul>
<p>（存在正数c和<span class="arithmatex">\(n_0\)</span>使得对于一切<span class="arithmatex">\(n\geq n_0\)</span>），<span class="arithmatex">\(0\leq f(n)\leq cg(n)\)</span></p>
<ul>
<li>
<p>算法复杂度分析步骤</p>
</li>
<li>
<p>确定表示输入规模的参数</p>
</li>
<li>找出算法的基本操作</li>
<li>检查基本操作的执行次数是否只依赖于输入规模。这决定是否需要考虑最差、平均以及最优情况下的复杂性</li>
<li>对于非递归算法，建立算法基本操作执行次数的求和表达式；对于递归算法，建立算法基本操作执行次数的递推关系及其初始条件</li>
<li>
<p>利用求和公式和法则建立一个操作次数的闭合公式，或者求解递推公式，确定增长的阶</p>
</li>
<li>
<p>递归算法两类复杂度分析</p>
</li>
</ul>
<hr />
<div class="arithmatex">\[
  T(n)=
          \begin{cases}
          O(1)  &amp; n=1\\
          aT(n-1)+f(n)&amp; n&gt;1
          \end{cases}
\]</div>
<div class="arithmatex">\[
  T(n)=a^{n-1}T(1)+\sum_{i=2}^n a^{n-i}f(i)
\]</div>
<hr />
<div class="arithmatex">\[
  T(n)=
          \begin{cases}
          O(1)  &amp; n=1\\
          aT(\frac nb)+f(n)&amp; n&gt;1
          \end{cases}
\]</div>
<div class="arithmatex">\[
  T(n)=n^{log_b a}T(1)+\sum_{j=0}^{log_b n-1}a^jf(\frac n{b^j})
\]</div>
<h1 id="线性表">线性表<a class="headerlink" href="#线性表" title="Permanent link">&para;</a></h1>
<h2 id="线性表的定义和基本操作">线性表的定义和基本操作<a class="headerlink" href="#线性表的定义和基本操作" title="Permanent link">&para;</a></h2>
<h4 id="定义">定义<a class="headerlink" href="#定义" title="Permanent link">&para;</a></h4>
<p>线性表是具有<strong>相同数据类型</strong>的n个数据元素的<strong>有限序列</strong>。其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则其一般表示为<span class="arithmatex">\(L=(a_1,a_2,...,a_i,a_{i+1},...,a_n)\)</span>。</p>
<h4 id="特点">特点<a class="headerlink" href="#特点" title="Permanent link">&para;</a></h4>
<ul>
<li><span class="arithmatex">\(a_1\)</span>是唯一的“第一个”数据元素，又称表头元素</li>
<li><span class="arithmatex">\(a_n\)</span>是唯一的“最后一个”数据元素，又称表尾元素</li>
<li>除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。</li>
</ul>
<h4 id="基本操作">基本操作<a class="headerlink" href="#基本操作" title="Permanent link">&para;</a></h4>
<p>```c++****
InitList(&amp;L):初始化表。构造一个空的线性表
Length(L):求表长
LocateElem(L,e):按值查找操作
GetElem(L,i):按位查找操作
ListInsert(&amp;L,i,e):插入操作
ListDelete(&amp;L,i,&amp;e):删除操作，并用e返回删除元素的值
PrintList(L):输出操作
Empty(L):判断操作
DestoryList(&amp;L):销毁操作
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code>## 线性表的顺序表示

### 顺序表的定义

线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。顺序表的特点是表中元素的逻辑顺序与物理顺序相同。

- 线性表A中第`i`个元素的内存地址：`&amp;(A[0])+i*sizeof(ElemType)`
- 一维数组可以是静态分配，也可以动态分配
- 静态分配时，数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃
- 动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间。

**静态分配的实现**

```c++
#define MaxSize 50              //定义线性表的最大长度
typedef struct{
    ElemType data[MaxSize];     //顺序表的元素
    int length;                 //顺序表的当前长度
}SqList;                        //顺序表的类型定义
</code></pre></div></td></tr></table></div></p>
<p><strong>动态分配的实现</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#define InitSize 100            </span><span class="c1">//表长度的初始定义</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="w">             </span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w">             </span><span class="c1">//指示动态分配数组的指针</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">MaxSize</span><span class="p">,</span><span class="n">length</span><span class="p">;</span><span class="w">         </span><span class="c1">//数组的最大容量和当前个数</span>
<span class="p">}</span><span class="n">SqList</span><span class="p">;</span><span class="w">                        </span><span class="c1">//动态分配数组顺序表的类型定义</span>
<span class="c1">//C的初始动态分配语句</span>
<span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ElemType</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ElemType</span><span class="p">)</span><span class="o">*</span><span class="n">InitSize</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
<span class="c1">//C++的初始动态分配语句</span>
<span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ElemType</span><span class="p">[</span><span class="n">InitSize</span><span class="p">];</span>
<span class="k">delete</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<h4 id="特点_1">特点<a class="headerlink" href="#特点_1" title="Permanent link">&para;</a></h4>
<ul>
<li>随机访问</li>
<li>存储密度高</li>
<li>插入删除需要移动大量元素</li>
</ul>
<h3 id="顺序表的实现">顺序表的实现<a class="headerlink" href="#顺序表的实现" title="Permanent link">&para;</a></h3>
<p><code>注意算法对i的描述是第i个元素，它是以1为起点的</code></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">ListInset</span><span class="p">(</span><span class="n">SqList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">e</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">||</span><span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">//判断插入位置是否有效</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">&gt;=</span><span class="n">MaxSize</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">//判断存储空间是否已满</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">];</span><span class="w">   </span><span class="c1">//将插入位置之后的元素后移</span>
<span class="w">    </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w">        </span><span class="c1">//赋值</span>
<span class="w">    </span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">++</span><span class="p">;</span><span class="w">             </span><span class="c1">//线性表长度+1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">ListDelete</span><span class="p">(</span><span class="n">SqList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">||</span><span class="n">i</span><span class="o">&gt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">   </span><span class="c1">//判断值是否有效</span>
<span class="w">    </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span><span class="w">        </span><span class="c1">//赋值，用于返回</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">  </span><span class="c1">//删除元素后的元素前移</span>
<span class="w">    </span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="o">--</span><span class="p">;</span><span class="w"> </span><span class="c1">//线性表长度-1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">    </span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">LocateElem</span><span class="p">(</span><span class="n">SqList</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">e</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">L</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">         </span><span class="c1">//注意这里的下标</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h2 id="线性表的链式表示">线性表的链式表示<a class="headerlink" href="#线性表的链式表示" title="Permanent link">&para;</a></h2>
<h3 id="单链表">单链表<a class="headerlink" href="#单链表" title="Permanent link">&para;</a></h3>
<ul>
<li>结点描述：</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">LNode</span><span class="p">{</span><span class="w">       </span><span class="c1">//定义单链表结点类型</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">          </span><span class="c1">//数据域</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">     </span><span class="c1">//指针域</span>
<span class="p">}</span><span class="n">LNode</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">LinkList</span><span class="p">;</span><span class="w">      </span><span class="c1">//LinkList为指向结构体LNODE的指针类型</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>通常用头指针来标示一个单链表。</li>
<li>有头结点或者没头结点之分</li>
<li>头结点的作用</li>
<li>便于首元结点的处理，对链表的第一个数据元素的操作与其他数据元素相同，无需特殊处理</li>
<li>便于空表与非空表的统一处理：头指针永远不为空</li>
</ul>
<h3 id="单链表的实现">单链表的实现<a class="headerlink" href="#单链表的实现" title="Permanent link">&para;</a></h3>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">LinkList</span><span class="w"> </span><span class="nf">List_HeadInsert</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
<span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span><span class="c1">//创建头结点</span>
<span class="w">    </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">                 </span><span class="c1">//初始为空链表</span>
<span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LNode</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
<span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">LinkList</span><span class="w"> </span><span class="nf">List_TailInsert</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="o">&amp;</span><span class="n">L</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LinkList</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
<span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">r</span><span class="o">=</span><span class="n">L</span><span class="p">;</span><span class="w">          </span><span class="c1">//r为表尾指针</span>
<span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">9999</span><span class="p">){</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LNode</span><span class="p">));</span>
<span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">        </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">             </span><span class="c1">//尾结点指针置空</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="nf">LocateElem</span><span class="p">(</span><span class="n">LinkList</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">e</span><span class="p">){</span><span class="c1">//按值查找</span>
<span class="w">    </span><span class="n">LNode</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">!=</span><span class="n">e</span><span class="p">)</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="双链表">双链表<a class="headerlink" href="#双链表" title="Permanent link">&para;</a></h3>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">DNode</span><span class="p">{</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">DNode</span><span class="w"> </span><span class="o">*</span><span class="n">prior</span><span class="p">,</span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">  </span><span class="c1">//前驱和后继指针</span>
<span class="p">}</span><span class="n">DNode</span><span class="p">,</span><span class="o">*</span><span class="n">DLinkList</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<h3 id="循环链表">循环链表<a class="headerlink" href="#循环链表" title="Permanent link">&para;</a></h3>
<ul>
<li>循环单链表</li>
<li>循环双链表</li>
</ul>
<h3 id="静态链表">静态链表<a class="headerlink" href="#静态链表" title="Permanent link">&para;</a></h3>
<p>借助数组来描述线性表的链式存储结构，结点也有数据域<code>data</code>和指针域<code>next</code>，这里的指针是节点的相对地址（数组下标），又称<strong>游标</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#define MaxSize 50</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">SLinkList</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span>
</code></pre></div></td></tr></table></div>
<h1 id="栈和队列">栈和队列<a class="headerlink" href="#栈和队列" title="Permanent link">&para;</a></h1>
<h2 id="栈">栈<a class="headerlink" href="#栈" title="Permanent link">&para;</a></h2>
<h3 id="栈的基本概念">栈的基本概念<a class="headerlink" href="#栈的基本概念" title="Permanent link">&para;</a></h3>
<h4 id="栈的定义">栈的定义<a class="headerlink" href="#栈的定义" title="Permanent link">&para;</a></h4>
<ul>
<li>栈是只允许在一端进行插入或删除操作的线性表。后进先出<code>LIFO</code></li>
<li>栈顶<code>Top</code>：线性表允许进行插入删除的那一端。</li>
<li>栈底<code>Bottom</code>：固定的，不允许进行插入和删除的另一端</li>
<li>空栈：不包含任何元素的空表</li>
</ul>
<h4 id="栈的基本操作">栈的基本操作<a class="headerlink" href="#栈的基本操作" title="Permanent link">&para;</a></h4>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">InitStack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">初始化一个空栈S</span>
<span class="n">StackEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">判断一个栈是否为空</span><span class="err">，</span><span class="n">若栈S为空则返回true</span><span class="err">，</span><span class="n">否则返回false</span>
<span class="n">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">进栈</span><span class="err">，</span><span class="n">若栈S未满</span><span class="err">，</span><span class="n">则将x加入使之成为新栈顶</span>
<span class="n">Pop</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">出栈</span><span class="err">，</span><span class="n">若栈S非空</span><span class="err">，</span><span class="n">则弹出栈顶元素</span><span class="err">，</span><span class="n">并用x返回</span>
<span class="n">GetTop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">读取栈顶元素</span><span class="err">，</span><span class="n">若栈S非空</span><span class="err">，</span><span class="n">则用x返回栈顶元素</span>
<span class="n">DestroyStack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">销毁栈</span><span class="err">，</span><span class="n">并释放栈S占用的存储空间</span>
</code></pre></div></td></tr></table></div>
<h3 id="栈的顺序存储结构">栈的顺序存储结构<a class="headerlink" href="#栈的顺序存储结构" title="Permanent link">&para;</a></h3>
<h4 id="顺序栈的实现">顺序栈的实现<a class="headerlink" href="#顺序栈的实现" title="Permanent link">&para;</a></h4>
<p>利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，并附设一个指针<code>top</code>指示当前栈顶元素的位置</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#define MaxSize 50          </span><span class="c1">//定义栈中元素最大个数</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span>
<span class="w">    </span><span class="n">Elemtype</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="w"> </span><span class="c1">//存放栈中元素</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="p">;</span><span class="c1">//栈顶指针</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>栈顶指针：<code>S.top</code>，初始时设置<code>S.top=-1</code>；栈顶元素：<code>S.data[S.top]</code></li>
<li>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素</li>
<li>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1</li>
<li>栈空条件：<code>S.top==-1</code>；栈满条件：<code>S.top==MaxSize-1</code>；栈长：<code>S.top+1</code></li>
</ul>
<h4 id="共享栈">共享栈<a class="headerlink" href="#共享栈" title="Permanent link">&para;</a></h4>
<p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶共享空间的中间延伸。</p>
<ul>
<li>
<p>两个栈的栈顶指针都指向栈顶元素</p>
</li>
<li>
<p><code>top0=-1</code>时0号栈为空，<code>top1=MaxSize</code>时<code>1</code>号栈为空</p>
</li>
<li><code>top1-top0==1</code>为栈满</li>
<li>当<code>0</code>号栈进栈时<code>top0</code>先加1再赋值，<code>1</code>号栈进栈时<code>top1</code>先减1再赋值；出栈是刚好相反</li>
</ul>
<h3 id="栈的链式存储结构">栈的链式存储结构<a class="headerlink" href="#栈的链式存储结构" title="Permanent link">&para;</a></h3>
<p>采用链式存储的栈称为<strong>链栈</strong>，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。这里规定链栈没有头结点，<code>Lhead</code>指向栈顶元素</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Linknode</span><span class="p">{</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="c1">//数据域</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Linknode</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="c1">//指针域</span>
<span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="n">LiStack</span><span class="p">;</span><span class="c1">//栈类型定义  </span>
</code></pre></div></td></tr></table></div>
<h2 id="队列">队列<a class="headerlink" href="#队列" title="Permanent link">&para;</a></h2>
<h3 id="队列的基本概念">队列的基本概念<a class="headerlink" href="#队列的基本概念" title="Permanent link">&para;</a></h3>
<h4 id="队列的定义">队列的定义<a class="headerlink" href="#队列的定义" title="Permanent link">&para;</a></h4>
<ul>
<li>队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。</li>
<li>向队列中插入元素称为<strong>入队</strong>或<strong>进队</strong></li>
<li>删除元素称为<strong>出队</strong>或<strong>离队</strong></li>
<li>操作的特性是先进先出</li>
</ul>
<h4 id="队列常见的基本操作">队列常见的基本操作<a class="headerlink" href="#队列常见的基本操作" title="Permanent link">&para;</a></h4>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">InitQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span><span class="o">:</span><span class="n">初始化队列</span><span class="err">，</span><span class="n">构造一个空队列Q</span>
<span class="n">QueueEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">:</span><span class="n">判队列空</span>
<span class="n">EnQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">入队</span><span class="err">，</span><span class="n">若队列Q非满</span><span class="err">，</span><span class="n">将x加入</span><span class="err">，</span><span class="n">使之成为新的队尾</span>
<span class="n">DeQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">出队</span><span class="err">，</span><span class="n">若队列Q非空</span><span class="err">，</span><span class="n">删除队头元素</span><span class="err">，</span><span class="n">并用x返回</span>
<span class="n">GetHead</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">读队头元素</span><span class="err">，</span><span class="n">若队列Q非空</span><span class="err">，</span><span class="n">则将队头元素赋值给x</span>
</code></pre></div></td></tr></table></div>
<h3 id="队列的顺序存储结构">队列的顺序存储结构<a class="headerlink" href="#队列的顺序存储结构" title="Permanent link">&para;</a></h3>
<h4 id="队列的顺序存储">队列的顺序存储<a class="headerlink" href="#队列的顺序存储" title="Permanent link">&para;</a></h4>
<p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针<code>front</code>指向队头元素，队尾指针<code>rear</code>指向队尾元素的下一个位置</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#define MaxSize 50</span><span class="c1">//定义队列中元素的最大个数</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">MaxSize</span><span class="p">];</span><span class="c1">//存放队列元素</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">front</span><span class="p">,</span><span class="n">rear</span><span class="p">;</span><span class="c1">//队头指针和队尾指针</span>
<span class="p">}</span><span class="w"> </span><span class="n">SqQueue</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>初始状态：<code>Q.front==Q.rear==0</code></li>
<li>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1</li>
<li>出队操作：队不空时，先取队头元素值，再将队头指针加1</li>
</ul>
<h4 id="循环队列">循环队列<a class="headerlink" href="#循环队列" title="Permanent link">&para;</a></h4>
<p>将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针<code>Q.front=MaxSize-1</code>后，再前进一个位置就自动到0，这可以利用除法取余运算<code>%</code>来实现</p>
<ul>
<li>初始状态：<code>Q.front=Q.rear=0</code></li>
<li>队首指针进1：<code>Q.front=(Q.front+1)%MaxSize</code></li>
<li>队尾指针进1：<code>Q.rear=(Q.rear+1)%MaxSize</code></li>
<li>队列长度：<code>(Q.rear+MaxSize-Q.front)%MaxSize</code></li>
<li>出队入队时：指针都按顺时针方向进1</li>
</ul>
<p><strong>判断循环队列队空或队满的三种方式</strong></p>
<ol>
<li>
<p>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，约定以“队头指针在队尾指针的下一位置作为队满的标志”</p>
</li>
<li>
<p>队满条件：<code>(Q.rear+1)%MaxSize==Q.front</code></p>
</li>
<li>队空条件：<code>Q.front=Q.rear</code></li>
<li>
<p>队列中元素的个数：<code>(Q.rear-Q.front+MaxSize)%MaxSize</code></p>
</li>
<li>
<p>类型中增设表示元素个数的数据成员。</p>
</li>
<li>
<p>队空条件：<code>Q.size==0</code></p>
</li>
<li>
<p>队满条件：<code>Q.size==MaxSize</code></p>
</li>
<li>
<p>类型中增设<code>tag</code>数据成员，以区分是队满还是队空。</p>
</li>
<li>
<p><code>tag=0</code>时，若因删除导致<code>Q.front==Q.rear</code>,则为队空</p>
</li>
<li>
<p><code>tag=1</code>时，若因插入导致<code>Q.front==Q.rear</code>,则为队满</p>
</li>
</ol>
<h3 id="队列的链式存储结构">队列的链式存储结构<a class="headerlink" href="#队列的链式存储结构" title="Permanent link">&para;</a></h3>
<h4 id="队列的链式存储">队列的链式存储<a class="headerlink" href="#队列的链式存储" title="Permanent link">&para;</a></h4>
<p>队列的链式表示称为链队列，它实际是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="c1">//链式队列结点</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">LinkNdoe</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">LinkNode</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span><span class="c1">//链式队列</span>
<span class="w">    </span><span class="n">LinkNode</span><span class="w"> </span><span class="o">*</span><span class="n">front</span><span class="p">,</span><span class="o">*</span><span class="n">rear</span><span class="p">;</span><span class="c1">//队列的队头和队尾指针</span>
<span class="p">}</span><span class="n">LinkQueue</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<p>通常将链式队列设计成一个带头结点对的单链表，这样插入和删除就统一了</p>
<h3 id="双端队列">双端队列<a class="headerlink" href="#双端队列" title="Permanent link">&para;</a></h3>
<p>双端队列是指允许两端都可进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端。</p>
<ul>
<li>输出受限的双端队列：允许在一端进行插入和删除，另一端只允许插入的双端队列</li>
<li>输入受限的双端队列：允许在一端进行插入和删除，另一端只允许删除的双端队列</li>
</ul>
<h2 id="栈和队列的应用">栈和队列的应用<a class="headerlink" href="#栈和队列的应用" title="Permanent link">&para;</a></h2>
<h4 id="栈在括号匹配中的应用">栈在括号匹配中的应用<a class="headerlink" href="#栈在括号匹配中的应用" title="Permanent link">&para;</a></h4>
<ul>
<li>初始设置一个空栈，顺序读入括号</li>
<li>若是右括号，则或者置于栈顶的最急迫期待得以消解，或者是不合法的情况</li>
<li>若是左括号，则作为一个新的更急迫的期待压入栈中</li>
<li>算法结束时，栈为空，否则括号序列不匹配</li>
</ul>
<h4 id="栈在表达式求值中的应用">栈在表达式求值中的应用<a class="headerlink" href="#栈在表达式求值中的应用" title="Permanent link">&para;</a></h4>
<h5 id="后续表达式计算方式">后续表达式计算方式<a class="headerlink" href="#后续表达式计算方式" title="Permanent link">&para;</a></h5>
<p>顺序扫描表达式的每一项，然后根据它的类型作出如下相应操作：若该项是操作数，则将其压入栈中；若该项是操作符<code>&lt;op&gt;</code>，则连续从栈中退出两个操作数<code>Y</code>和<code>X</code>，形成运算指令<code>X&lt;op&gt;Y</code>，并将计算结果重新压入栈中。当表达式的所有项扫描并处理完毕后，栈顶存放的就是最后的结果</p>
<h5 id="中缀表达式转换为前缀或后缀表达式的手工做法">中缀表达式转换为前缀或后缀表达式的手工做法<a class="headerlink" href="#中缀表达式转换为前缀或后缀表达式的手工做法" title="Permanent link">&para;</a></h5>
<ul>
<li>按照运算符的优先级对所有的运算单位加括号</li>
<li>转换为前缀或后缀表达式。前缀把运算符移动到对应的括号前面，后缀把运算符移动到对应的括号后面</li>
<li>把括号去掉</li>
</ul>
<h5 id="中缀表达式转换为后缀表达式的算法思路">中缀表达式转换为后缀表达式的算法思路<a class="headerlink" href="#中缀表达式转换为后缀表达式的算法思路" title="Permanent link">&para;</a></h5>
<ul>
<li>从左向右开始扫描中缀表达式</li>
<li>遇到数字时，加入后缀表达式</li>
<li>遇到运算符时</li>
<li>若为<code>(</code>,入栈</li>
<li>若为<code>)</code>，则依次把栈中的运算符加入后缀表达式，直到出现<code>(</code>,从栈中删除<code>(</code></li>
<li>若为除括号外的其他运算符，当其优先级高于除<code>(</code>外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的运算符优先级高和优先级相等的运算符，直到一个比它优先级低的或遇到一个左括号为止。</li>
</ul>
<h4 id="栈在递归中的应用">栈在递归中的应用<a class="headerlink" href="#栈在递归中的应用" title="Permanent link">&para;</a></h4>
<p>可以将递归算法转换为非递归算法。通常需要借助栈来实现这种转换</p>
<h4 id="队列在层次遍历中的应用">队列在层次遍历中的应用<a class="headerlink" href="#队列在层次遍历中的应用" title="Permanent link">&para;</a></h4>
<ol>
<li>根节点入队</li>
<li>若队空，则结束遍历；否则重复<code>3</code>操作</li>
<li>队列中第一个结点出队，并访问之。若其没有左孩子，则将左孩子入队，若其有左孩子，则将其右孩子入队，返回<code>2</code></li>
</ol>
<h4 id="队列在计算机系统中的应用">队列在计算机系统中的应用<a class="headerlink" href="#队列在计算机系统中的应用" title="Permanent link">&para;</a></h4>
<ul>
<li>解决主机与外部设备之间速度不匹配的问题</li>
<li>解决由多用户引起的资源竞争问题</li>
</ul>
<h2 id="特殊矩阵的压缩存储">特殊矩阵的压缩存储<a class="headerlink" href="#特殊矩阵的压缩存储" title="Permanent link">&para;</a></h2>
<h4 id="数组的定义">数组的定义<a class="headerlink" href="#数组的定义" title="Permanent link">&para;</a></h4>
<p><strong>数组</strong>是由n个相同类型的数据元素构成的有限序列，每个数据元素成为一个<strong>数据元素</strong>，每个元素在n个线性关系中的序号称为该元素的<strong>下标</strong>，下标的取值范围称为数组的<strong>维界</strong></p>
<p>数组是线性表的推广。一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表。</p>
<h4 id="数组的存储结构">数组的存储结构<a class="headerlink" href="#数组的存储结构" title="Permanent link">&para;</a></h4>
<p>多维数组的映方法：按行优先和按列优先</p>
<h4 id="矩阵的压缩存储">矩阵的压缩存储<a class="headerlink" href="#矩阵的压缩存储" title="Permanent link">&para;</a></h4>
<p>指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间</p>
<h4 id="稀疏矩阵">稀疏矩阵<a class="headerlink" href="#稀疏矩阵" title="Permanent link">&para;</a></h4>
<p>矩阵中非零元素的个数远远小于矩阵元素的个数</p>
<p>使用<strong>三元组</strong>（行、列、值）或<strong>十字链表法</strong>存储，失去了<strong>随机存取特性</strong></p>
<h1 id="串">串<a class="headerlink" href="#串" title="Permanent link">&para;</a></h1>
<h2 id="串的定义和实现">串的定义和实现<a class="headerlink" href="#串的定义和实现" title="Permanent link">&para;</a></h2>
<h3 id="串的定义">串的定义<a class="headerlink" href="#串的定义" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><strong>串</strong>（String）是由零个或多个字符组成的有限序列。记为<span class="arithmatex">\(S='a_1a_2...a_n'\)</span></p>
</li>
<li>
<p>串中任意多个连续的字符组成的子序列称为该串的<strong>子串</strong></p>
</li>
<li>包含子串的串称为<strong>主串</strong></li>
<li>由一个或多个空格组成的串称为<strong>空格串</strong></li>
</ul>
<h3 id="串的存储结构">串的存储结构<a class="headerlink" href="#串的存储结构" title="Permanent link">&para;</a></h3>
<h4 id="定长顺序存储表示">定长顺序存储表示<a class="headerlink" href="#定长顺序存储表示" title="Permanent link">&para;</a></h4>
<p>用一组地址连续的存储单元存储串值的字符序列</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#define MAXLEN 255</span><span class="c1">//预定义最大串长为255</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">[</span><span class="n">MAXLEN</span><span class="p">];</span><span class="c1">//每个分量存储一个字符</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="c1">//串的实际长度</span>
<span class="p">}</span><span class="n">SString</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<h4 id="堆分配存储表示">堆分配存储表示<a class="headerlink" href="#堆分配存储表示" title="Permanent link">&para;</a></h4>
<p>堆分配存储仍然以一组地址连续的存储单元存放串值的字符序列，但他们的存储空间是在程序执行过程中动态分配得到的</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ch</span><span class="p">;</span><span class="c1">//按串分配存储区，ch指向串的基地址</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="c1">//串的长度</span>
<span class="p">}</span><span class="n">HString</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<p>在<code>C</code>语言中，存在一个称之为<strong>堆</strong>的自由存储区，并用<code>malloc()</code>和<code>free()</code>函数来完成动态存储管理</p>
<p>利用<code>malloc()</code>为每个新产生的串分配一块实际串长所需要的存储空间，若分配成功，则返回一个指向起始地址的指针，称为串的基地址，这个串由<code>ch</code>指针来指示;若分配失败，则返回<code>NULL</code>。已分配的空间可用<code>free()</code>释放掉</p>
<h4 id="块链存储表示">块链存储表示<a class="headerlink" href="#块链存储表示" title="Permanent link">&para;</a></h4>
<p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性，在具体实现时，每个节点即可以存放一个字符，也可以存放多个字符，每个节点称为<strong>块</strong>，整个链表称为<strong>块链结构</strong></p>
<h3 id="串的基本操作">串的基本操作<a class="headerlink" href="#串的基本操作" title="Permanent link">&para;</a></h3>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">StrAssign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">chars</span><span class="p">)</span><span class="o">:</span><span class="n">赋值操作</span><span class="err">。</span><span class="n">把串T赋值为chars</span>
<span class="n">StrCopy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">复制操作</span><span class="err">。</span><span class="n">由串S复制得到串T</span>
<span class="n">StrEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">判空操作</span><span class="err">。</span><span class="n">若S为空串</span><span class="err">，</span><span class="n">则返回TRUE</span><span class="err">，</span><span class="n">否则返回FALSE</span>
<span class="n">StrCompare</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span><span class="o">:</span><span class="n">比较操作</span><span class="err">，</span><span class="n">S</span><span class="o">&gt;</span><span class="n">T则返回值</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">k若S</span><span class="o">=</span><span class="n">T</span><span class="err">，</span><span class="n">返回0</span><span class="err">，</span><span class="n">否则返回</span><span class="o">&lt;</span><span class="mi">0</span>
<span class="n">StrLength</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">求串长</span>
<span class="n">SubString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Sub</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">len</span><span class="p">)</span><span class="o">:</span><span class="n">求子串</span><span class="err">。</span><span class="n">用Sub返回串S的第pos个字符起长度为len的子串</span>
<span class="n">Concat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span><span class="o">:</span><span class="n">串联接</span><span class="err">。</span><span class="n">用T返回S1和S2的联接</span>
<span class="n">Index</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">T</span><span class="p">)</span><span class="o">:</span><span class="n">定位操作</span>
<span class="n">ClearString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">清空</span>
<span class="n">DestroyString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">S</span><span class="p">)</span><span class="o">:</span><span class="n">销毁串</span>
</code></pre></div></td></tr></table></div>
<h2 id="串的模式匹配">串的模式匹配<a class="headerlink" href="#串的模式匹配" title="Permanent link">&para;</a></h2>
<h3 id="简单的模式匹配算法bf">简单的模式匹配算法BF<a class="headerlink" href="#简单的模式匹配算法bf" title="Permanent link">&para;</a></h3>
<p>子串的定位操作通常称为串的<strong>模式匹配</strong>，它求的是子串在主串中的位置</p>
<h3 id="利用有限自动机进行字符串匹配">利用有限自动机进行字符串匹配<a class="headerlink" href="#利用有限自动机进行字符串匹配" title="Permanent link">&para;</a></h3>
<h4 id="有限自动机">有限自动机<a class="headerlink" href="#有限自动机" title="Permanent link">&para;</a></h4>
<p>有限自动机<span class="arithmatex">\(M\)</span>是一个5元组<span class="arithmatex">\((Q,q_0,A,\sum,\delta)\)</span>
- Q是<strong>状态</strong>的有限集合
- <span class="arithmatex">\(q_0 \in Q\)</span>是<strong>初始状态</strong>
- <span class="arithmatex">\(A \subseteq Q\)</span>是一个特殊的<strong>接受状态</strong>集合
- <span class="arithmatex">\(\sum\)</span>是有限<strong>输入字母表</strong>
- <span class="arithmatex">\(\delta\)</span>是一个从<span class="arithmatex">\(Q \times \sum\)</span>到<span class="arithmatex">\(Q\)</span>的函数，称为<span class="arithmatex">\(M\)</span>的<strong>转移函数</strong></p>
<p>有限自动机开始于状态<span class="arithmatex">\(q_0\)</span>，每次读入输入字符串的一个字符。如果有限自动机在状态<span class="arithmatex">\(q\)</span>时读入了字符<span class="arithmatex">\(a\)</span>，则它从状态<span class="arithmatex">\(q\)</span>变为状态<span class="arithmatex">\(\delta(q,a)\)</span>。每当其当前状态<span class="arithmatex">\(q\)</span>属于<span class="arithmatex">\(A\)</span>时，就说自动机<span class="arithmatex">\(M\)</span>接受了迄今为止读入的字符串。没有被接受的输入称为被拒绝的输入。</p>
<p>有限zidongji1M引入一个函数<span class="arithmatex">\(\phi\)</span>，称为终态函数，它是从<span class="arithmatex">\(∑^*\)</span>到<span class="arithmatex">\(Q\)</span>的函数，满足<span class="arithmatex">\(\phi(w)\)</span>是M在扫描字符串w后终止时的状态。因此，当且仅当<span class="arithmatex">\(\phi(w) \in A\)</span>时，M接受字符串w。我们可以用转移函数递归定义<span class="arithmatex">\(\phi\)</span></p>
<div class="arithmatex">\[
\phi(\epsilon) = q_0 &lt;br&gt;
\phi(wa) = \delta(\phi(w),a),w\in ∑^*,a\in \Sum
\]</div>
<h4 id="字符串匹配自动机">字符串匹配自动机<a class="headerlink" href="#字符串匹配自动机" title="Permanent link">&para;</a></h4>
<p>对于给定的要查找的字符串，构造它的一个字符串匹配自动机
定义一个辅助函数<span class="arithmatex">\(\sigma(x)=\max \{k:P_k是x的后缀\}\)</span></p>
<p>给定模式<span class="arithmatex">\(P[1..m]\)</span>，其相应的1字符串匹配自动机定义如下：
- 状态集合<span class="arithmatex">\(Q:\{0,1,...,m\}\)</span>。开始状态<span class="arithmatex">\(q_0\)</span>是0状态，并且只有状态m是唯一被接受的状态
- 对任意的状态q和字符a，转移函数<span class="arithmatex">\(\delta\)</span>的定义为<span class="arithmatex">\(\delta(q,a)=\sigma(P_q a)\)</span></p>
<h3 id="kmp算法">KMP算法<a class="headerlink" href="#kmp算法" title="Permanent link">&para;</a></h3>
<h4 id="基础概念">基础概念<a class="headerlink" href="#基础概念" title="Permanent link">&para;</a></h4>
<ul>
<li>前缀：除最后一个字符以外，字符串的所有头部子串</li>
<li>后缀：除第一个字符外，字符串的所有尾部子串</li>
<li>部分匹配值<code>PM</code>：字符串的前缀和后缀的最长相等前后缀长度</li>
</ul>
<h4 id="算法原理">算法原理<a class="headerlink" href="#算法原理" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>编号</th>
<th>描述</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S</code></td>
<td>字符</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
<td>c</td>
</tr>
<tr>
<td><code>PM</code></td>
<td>子串右移位数=已匹配的字符数-对应的部分匹配值：<code>Move=(j-1)-PM[j-1]</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>next</code>（PM右移一位）</td>
<td>子串右移位数：<code>Move=(j-1)-next[j]</code>，子串的比较指针回退到：<code>j=next[j]+1</code></td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><code>next=next+1</code></td>
<td>在子串的第<code>j</code>个字符与主串发生失配时，则跳到子串的<code>next[j]位置重新与主串当前位置进行比较</code></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<h4 id="next推导方法">next[]推导方法<a class="headerlink" href="#next推导方法" title="Permanent link">&para;</a></h4>
<p>-</p>
<div class="arithmatex">\[
  next[j]=
  \begin{cases}
  0  &amp; j=1\\
  max\{k|1&lt;k&lt;j且'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'\}&amp; 当此集合不空时     \\
  1&amp; 其他情况
  \end{cases} \tag{next[ ]推导公式}
\]</div>
<ul>
<li>next的推导步骤，<code>next[j]=k</code>,求<code>next[j+1]</code></li>
</ul>
<p><code>next[j]=k</code>表明<span class="arithmatex">\(p_1...p_{k-1}=p_{j-k+1}...p_{j-1}\)</span></p>
<ol>
<li>若<span class="arithmatex">\(p_k=p_j\)</span>,则<code>next[j+1]=next[j]+1</code></li>
<li>若<span class="arithmatex">\(p_k \neq p_j\)</span>。用前缀<span class="arithmatex">\(p_1...p_k\)</span>去跟后缀<span class="arithmatex">\(p_{j-k+1}...p_j\)</span>匹配，则当<span class="arithmatex">\(p_k \neq p_j\)</span>是应将<span class="arithmatex">\(p_1...p_k\)</span>向右滑动至以第<code>next[k]</code>个字符与<span class="arithmatex">\(p_j\)</span>比较，如果<span class="arithmatex">\(p_{next[k]}\)</span>与<span class="arithmatex">\(p_j\)</span>还是不匹配,那么需要寻找长度更短的相等前后缀，下一步继续用<span class="arithmatex">\(P_{next[next[k]]}\)</span>与<span class="arithmatex">\(p_j\)</span>比较,直到找到<code>k'=next[next...[k]]</code>满足条件<span class="arithmatex">\('p_1...p_{k'}'='p_{j-k'+1}...p_{j}'\)</span>,则<code>next[j+1]=k'+1</code></li>
</ol>
<h4 id="说明">说明<a class="headerlink" href="#说明" title="Permanent link">&para;</a></h4>
<ul>
<li>为什么<code>next[1]=0</code>：当模式串中的第一个字符与主串的的当前字符比较不相等时，<code>next[1]=0</code>,表示模式串应该右移一位，主串当前指针后移一位，再和模式串的第一个字符进行比较</li>
<li>为什么要取<code>max{k}</code>：当主串的第<code>i</code>个字符与模式串的第<code>j</code>个字符失配时，主串<code>i</code>不回溯，则假定模式串的第<code>k</code>个字符与主串的第<code>i</code>个字符比较,<code>k</code>应满足条件<span class="arithmatex">\(1&lt;k&lt;j且'p_1...p_{k-1}'='p_{j-k+1}...p_{j-1}'\)</span>。为了不使向右移动丢失可能的匹配，右移距离应该取最小，由于<span class="arithmatex">\(j-k\)</span>表示右移距离，所以取<span class="arithmatex">\(max\{k\}\)</span>。</li>
</ul>
<h3 id="kmp算法的进一步优化">KMP算法的进一步优化<a class="headerlink" href="#kmp算法的进一步优化" title="Permanent link">&para;</a></h3>
<p><code>nextval[]</code>,如果出现了<span class="arithmatex">\(p_j=p_{next[j]}\)</span>,则将<code>next[j]</code>修正为<code>next[ next[j] ]</code>,直到两者不相等</p>
<h1 id="树与二叉树">树与二叉树<a class="headerlink" href="#树与二叉树" title="Permanent link">&para;</a></h1>
<h2 id="树">树<a class="headerlink" href="#树" title="Permanent link">&para;</a></h2>
<h3 id="树的定义">树的定义<a class="headerlink" href="#树的定义" title="Permanent link">&para;</a></h3>
<ul>
<li>有且仅有一个特定的称为根的结点</li>
<li>当<span class="arithmatex">\(n&gt;1\)</span>时，其余结点可分为<span class="arithmatex">\(m\)</span>个互不相交的有限集<span class="arithmatex">\(T_1,T_2,...,T_m\)</span>，其中每个集合本身又是一棵树，并且称为根的子树</li>
</ul>
<h3 id="基本术语">基本术语<a class="headerlink" href="#基本术语" title="Permanent link">&para;</a></h3>
<p>祖先、子孙、双亲、孩子、兄弟</p>
<p>结点的度、树的度</p>
<p>分支结点、叶子节点</p>
<p>节点的深度、高度、层次</p>
<p>有序树和无序树</p>
<p>路径和路径长度</p>
<p>森林</p>
<h3 id="树的性质">树的性质<a class="headerlink" href="#树的性质" title="Permanent link">&para;</a></h3>
<ul>
<li>树中的节点数等于所有结点的度数之和加1</li>
<li>总结点数=<span class="arithmatex">\(n_0+n_1+n_2+...+n_m\)</span></li>
<li>总分支数=<span class="arithmatex">\(1n_1+2n_2+...+mn_m\)</span></li>
<li>总结点数=总分支数+1</li>
</ul>
<h2 id="二叉树">二叉树<a class="headerlink" href="#二叉树" title="Permanent link">&para;</a></h2>
<h3 id="二叉树的定义及其主要特性">二叉树的定义及其主要特性<a class="headerlink" href="#二叉树的定义及其主要特性" title="Permanent link">&para;</a></h3>
<h4 id="定义_1">定义<a class="headerlink" href="#定义_1" title="Permanent link">&para;</a></h4>
<p>每个节点至多只有两棵子树，并且二叉树的子树有左右之分，不能颠倒</p>
<h4 id="几个特殊的二叉树">几个特殊的二叉树<a class="headerlink" href="#几个特殊的二叉树" title="Permanent link">&para;</a></h4>
<ul>
<li>满二叉树：一棵高度为h，且含有<span class="arithmatex">\(2^h-1\)</span>个结点的二叉树称为满二叉树，除叶子结点外每个结点度数为2</li>
<li>完全二叉树：每个结点都与同等高度的满二叉树有同样的编号</li>
<li>若<span class="arithmatex">\(i\leq \lfloor n/2 \rfloor\)</span>,则结点<code>i</code>为分支结点，否则为叶子结点</li>
<li>当<span class="arithmatex">\(2i\leq n\)</span>时，结点<code>i</code>的左孩子编号为<span class="arithmatex">\(2i\)</span>,否则无左孩子</li>
<li>当<span class="arithmatex">\(2i+1\leq n\)</span>时，结点<code>i</code>的右孩子编号为<span class="arithmatex">\(2i+1\)</span>,否则无右孩子</li>
<li>结点<code>i</code>所在的层次为<span class="arithmatex">\(\lfloor log_2i \rfloor +1\)</span></li>
<li>叶子结点只可能在层次最大的两层上出现，对于最大层次中的叶子结点，都依次排列在该层最左边的位置上</li>
<li>若有度为1的节点，则只可能有一个，且只有左孩子没有右孩子</li>
<li>若<code>n</code>为奇数，则每个分支结点都有左孩子和右孩子；若<code>n</code>为偶数，则编号最大的分支结点只有左孩子，没有右孩子</li>
<li>二叉排序树：左子树上所有节点的关键字小于根节点的关键字；右子树上的所有节点的关键字均大于根节点的关键字</li>
<li>平衡二叉树：树上任一节点的左子树和右子树的深度之差不超过1</li>
</ul>
<h4 id="二叉树的性质">二叉树的性质<a class="headerlink" href="#二叉树的性质" title="Permanent link">&para;</a></h4>
<ul>
<li>非空二叉树上的叶子结点数等于度为2的结点数+1，即<span class="arithmatex">\(n_0=n_2+1\)</span></li>
</ul>
<h3 id="二叉树的存储结构">二叉树的存储结构<a class="headerlink" href="#二叉树的存储结构" title="Permanent link">&para;</a></h3>
<h4 id="顺序存储结构">顺序存储结构<a class="headerlink" href="#顺序存储结构" title="Permanent link">&para;</a></h4>
<p>将完全二叉树上编号为<code>i</code>的结点元素存储在一维数组下标为<code>i-1</code>的分量中</p>
<p><strong>注意</strong>：这种存储结构建议从数组下标1开始存储树中的结点，若从数组下标0开始存储，则计算其孩子结点时与之前描述的计算公式不一致，在书写程序时需要注意。</p>
<h3 id="链式存储结构">链式存储结构<a class="headerlink" href="#链式存储结构" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th><code>lchild</code></th>
<th><code>data</code></th>
<th><code>rchild</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">BiTNode</span><span class="p">{</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="c1">//数据域</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">BiTNode</span><span class="w"> </span><span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//左、右孩子指针</span>
<span class="p">}</span><span class="n">BiTNode</span><span class="p">,</span><span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<p><code>n</code>个结点的二叉链表中，含有<code>n+1</code>个空链域</p>
<h2 id="二叉树的遍历和线索二叉树">二叉树的遍历和线索二叉树<a class="headerlink" href="#二叉树的遍历和线索二叉树" title="Permanent link">&para;</a></h2>
<h3 id="二叉树的遍历">二叉树的遍历<a class="headerlink" href="#二叉树的遍历" title="Permanent link">&para;</a></h3>
<p>二叉树的遍历是按照某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。共有先序遍历（NLR）、中序（LNR）、后续（LRN）三中遍历方法</p>
<h4 id="递归遍历算法">递归遍历算法<a class="headerlink" href="#递归遍历算法" title="Permanent link">&para;</a></h4>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">PreOrder</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span><span class="c1">//PreOrder-先序、InOrder-中序、PostOrder-后序</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
<span class="w">        </span><span class="n">visit</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="c1">//访问根结点</span>
<span class="w">        </span><span class="n">PreOrder</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span><span class="c1">//遍历访问左子树</span>
<span class="w">        </span><span class="n">PreOrder</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">rchlid</span><span class="p">);</span><span class="c1">//遍历访问右子树</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h4 id="非递归遍历算法">非递归遍历算法<a class="headerlink" href="#非递归遍历算法" title="Permanent link">&para;</a></h4>
<ul>
<li>先序遍历</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">PreOrder2</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span>
<span class="w">    </span><span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="o">=</span><span class="n">T</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span>
<span class="w">            </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span>
<span class="w">            </span><span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>中序遍历</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Inorder2</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span>
<span class="w">    </span><span class="n">InitStack</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="c1">//初始化S，p是遍历指针</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">||!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">S</span><span class="p">)){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="p">){</span><span class="c1">//一路向左</span>
<span class="w">            </span><span class="n">Push</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="c1">//当前结点入栈</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span><span class="c1">//左孩子不空，一直往左走</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="c1">//出栈，并转向出栈结点的左子树</span>
<span class="w">            </span><span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">p</span><span class="p">);</span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//栈顶元素出栈，访问出栈结点</span>
<span class="w">            </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span><span class="c1">//向右子树走</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>后序遍历</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code>
</code></pre></div></td></tr></table></div>
<ul>
<li>层次遍历</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">LevelOrder</span><span class="p">(</span><span class="n">BiTree</span><span class="w"> </span><span class="n">T</span><span class="p">){</span>
<span class="w">    </span><span class="n">InitQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">    </span><span class="n">BiTree</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">T</span><span class="p">);</span><span class="c1">//将根结点入队</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span>
<span class="w">        </span><span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="n">visit</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h4 id="由遍历序列构造二叉树">由遍历序列构造二叉树<a class="headerlink" href="#由遍历序列构造二叉树" title="Permanent link">&para;</a></h4>
<p>由二叉树中序遍历结果和前序、后序、层次中的一个组合，就可唯一确定一棵二叉树</p>
<h3 id="线索二叉树">线索二叉树<a class="headerlink" href="#线索二叉树" title="Permanent link">&para;</a></h3>
<h4 id="线索二叉树的基本概念">线索二叉树的基本概念<a class="headerlink" href="#线索二叉树的基本概念" title="Permanent link">&para;</a></h4>
<p>在含<code>n</code>个结点的二叉树中，有<code>n+1</code>个空指针。引入线索二叉树正是为了加快查找结点前驱和后继的速度。</p>
<p>规定：若无左子树，令<code>lchild</code>指向其前驱结点；若无右子树，令<code>rchild</code>指向其后继结点</p>
<table>
<thead>
<tr>
<th><code>lchild</code></th>
<th><code>ltag</code></th>
<th><code>data</code></th>
<th><code>rtag</code></th>
<th><code>rchild</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div class="arithmatex">\[
lchild=
\begin{cases}
0,&amp;lchild域指示结点的左孩子\\
1，&amp;lchild域指示结点的前驱
\end{cases}\\
rchild=
\begin{cases}
0,&amp;rchild域指示结点的右孩子\\
1，&amp;rchild域指示结点的后继
\end{cases}
\]</div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ThreadNode</span><span class="p">{</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ThreadNode</span><span class="w"> </span><span class="o">*</span><span class="n">lchild</span><span class="p">,</span><span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ltag</span><span class="p">,</span><span class="n">rtag</span><span class="p">;</span>
<span class="p">}</span><span class="n">ThreadNode</span><span class="p">,</span><span class="o">*</span><span class="n">ThreadTree</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<h4 id="中序线索二叉树的构造">中序线索二叉树的构造<a class="headerlink" href="#中序线索二叉树的构造" title="Permanent link">&para;</a></h4>
<p>线索化的实质就是遍历一次二叉树</p>
<h4 id="中序线索二叉树的遍历">中序线索二叉树的遍历<a class="headerlink" href="#中序线索二叉树的遍历" title="Permanent link">&para;</a></h4>
<p>在对其进行遍历时，只要先找到序列中的第一个节点，然后依次找结点的后继，直至后继为空。在中序线索二叉树中找结点后继的规律是：若其右标志为“1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点为其后继。</p>
<h4 id="先序线索二叉树和后序线索二叉树">先序线索二叉树和后序线索二叉树<a class="headerlink" href="#先序线索二叉树和后序线索二叉树" title="Permanent link">&para;</a></h4>
<p>后序线索二叉树上找后继时需要知道结点双亲，即需采用带标志域的三叉链表作为存储结构。</p>
<h2 id="树森林">树、森林<a class="headerlink" href="#树森林" title="Permanent link">&para;</a></h2>
<h3 id="树的存储结构">树的存储结构<a class="headerlink" href="#树的存储结构" title="Permanent link">&para;</a></h3>
<h4 id="双亲表示法">双亲表示法<a class="headerlink" href="#双亲表示法" title="Permanent link">&para;</a></h4>
<p>采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。</p>
<p>根节点的下标为0，其伪指针域为<code>-1</code></p>
<p>该存储结构利用了每个结点只有唯一双亲对的性质，可以很快的得到每个结点的双亲结点，但求结点的孩子需要遍历整个结构。</p>
<table>
<thead>
<tr>
<th><code>data</code></th>
<th><code>parent_pos</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="孩子表示法">孩子表示法<a class="headerlink" href="#孩子表示法" title="Permanent link">&para;</a></h4>
<p>将每个结点的孩子结点都用单链表链接起来形成一个线性结构</p>
<p>这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个结点中孩子结点指针域指向的n个孩子链表</p>
<h4 id="孩子兄弟表示法">孩子兄弟表示法<a class="headerlink" href="#孩子兄弟表示法" title="Permanent link">&para;</a></h4>
<p>又称<strong>二叉树表示法</strong>。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针。</p>
<table>
<thead>
<tr>
<th><code>data</code></th>
<th><code>firstchild</code></th>
<th><code>nextsibling</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="树森林与二叉树的转化">树、森林与二叉树的转化<a class="headerlink" href="#树森林与二叉树的转化" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>树转换为二叉树</p>
</li>
<li>
<p>规则：<strong>左孩子右兄弟</strong>。每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟</p>
</li>
<li>
<p>画法：1.在兄弟结点之间加一连线；2.对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；3.以树为轴心，顺时针旋转45°</p>
</li>
<li>
<p>特点：根无右子树</p>
</li>
<li>
<p>森林转换二叉树</p>
</li>
<li>规则：先将森林中的每棵树转换为二叉树；把第二棵树的根作为第一课树根的右兄弟，以此类推</li>
<li>画法：1.森林中的每棵树转换为相应的二叉树2.每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；3.以第一棵树的根为轴心顺时针旋转45°</li>
<li>特点：森林中每棵树的根节点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根节点的右指针为空。另外，每个非终端节点，其所有孩子结点在转换后，最后一个孩子的右指针也为空。</li>
<li>二叉树转换为森林</li>
<li>若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为由除第一棵树外的森林转换后的二叉树。</li>
</ul>
<h3 id="树和森林的遍历">树和森林的遍历<a class="headerlink" href="#树和森林的遍历" title="Permanent link">&para;</a></h3>
<h4 id="树的遍历">树的遍历<a class="headerlink" href="#树的遍历" title="Permanent link">&para;</a></h4>
<ul>
<li>先根遍历</li>
<li>后根遍历</li>
</ul>
<h4 id="森林的遍历">森林的遍历<a class="headerlink" href="#森林的遍历" title="Permanent link">&para;</a></h4>
<ul>
<li>先序遍历森林</li>
<li>访问森林中第一棵树的根节点</li>
<li>先序遍历第一棵树的根节点的子树森林</li>
<li>先序遍历除去第一棵树后剩余的树构成的森林</li>
<li>中序遍历森林（又称后根遍历）</li>
<li>中序遍历森林中第一课树的根节点的子树森林</li>
<li>访问第一课树的根结点</li>
<li>中序遍历除去第一棵树后剩余的树构成的森林</li>
</ul>
<h2 id="树与二叉树的应用">树与二叉树的应用<a class="headerlink" href="#树与二叉树的应用" title="Permanent link">&para;</a></h2>
<h3 id="二叉排序树bst">二叉排序树BST<a class="headerlink" href="#二叉排序树bst" title="Permanent link">&para;</a></h3>
<ul>
<li>二叉排序树的定义</li>
<li>
<p>左子树上所有节点的关键字小于根节点的关键字；右子树上的所有节点的关键字均大于根节点的关键字</p>
</li>
<li>
<p>二叉排序树的查找、插入、构造</p>
</li>
<li>
<p>二叉排序树的剔除</p>
</li>
<li>若被删除结点<code>z</code>是叶子结点，则直接删除</li>
<li>若结点<code>z</code>只有一棵左子树或右子树，则让<code>z</code>的子树成为<code>z</code>父节点的子树，替代<code>z</code>的位置</li>
<li>
<p>若结点<code>z</code>有左、右两棵子树，则令<code>z</code>的直接后继替代<code>z</code>，然后从二叉排序树中删去这个直接后继，这样就转换成了上面的两种情况</p>
</li>
<li>
<p>二叉排序树的查找效率分析</p>
</li>
<li><span class="arithmatex">\(O(log_2n)（平衡二叉树）\)</span>~<span class="arithmatex">\(O(n)\)</span></li>
<li><span class="arithmatex">\(ASL_a\)</span>:平均查找长度</li>
</ul>
<h3 id="平衡二叉树">平衡二叉树<a class="headerlink" href="#平衡二叉树" title="Permanent link">&para;</a></h3>
<ul>
<li>定义</li>
<li>
<p>任意结点的左右子树高度差的绝对值不超过1的二叉排序树</p>
</li>
<li>
<p>二叉排序树的插入</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LL</code>平衡旋转(右单旋转)</td>
</tr>
<tr>
<td><code>RR</code>平衡旋转(左单旋转)</td>
</tr>
<tr>
<td><code>LR</code>平衡旋转(先左后右双旋转)</td>
</tr>
<tr>
<td><code>RL</code>平衡旋转(先右后左双旋转)</td>
</tr>
</tbody>
</table>
<ul>
<li>平衡二叉树的查找</li>
<li>含有<span class="arithmatex">\(n\)</span>个结点的平衡二叉树的最大深度为<span class="arithmatex">\(O(log_2n)\)</span>,平均查找长度为<span class="arithmatex">\(O(log_2n)\)</span></li>
<li>平衡二叉树结点数的递推关系<span class="arithmatex">\(n_h=1+n_{h-1}+n_{h-2},n_0=0,n_1=1,n_2=2\)</span>,<span class="arithmatex">\(n_h\)</span>为构造此高度的平衡二叉树所需的最少结点数</li>
</ul>
<h3 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码<a class="headerlink" href="#哈夫曼树和哈夫曼编码" title="Permanent link">&para;</a></h3>
<h4 id="定义_2">定义<a class="headerlink" href="#定义_2" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>带权路径长度：<span class="arithmatex">\(WPL=\sum_{i=1}^nw_il_i\)</span></p>
</li>
<li>
<p>含有<code>n</code>个带权结点的二叉树中，带权路径长度<code>WPL</code>最小的二叉树称为哈夫曼树</p>
</li>
</ul>
<h4 id="哈夫曼树的构造">哈夫曼树的构造<a class="headerlink" href="#哈夫曼树的构造" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>将n个结点分别作为<code>n</code>棵仅含有一个结点的二叉树，构成森林<code>F</code></p>
</li>
<li>
<p>构造一个新结点，从<code>F</code>中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和</p>
</li>
<li>从<code>F</code>中删除刚才选出的两棵树，同时将新得到的树加入<code>F</code>中</li>
<li>重复2-3步骤</li>
</ol>
<h4 id="哈夫曼树特点">哈夫曼树特点<a class="headerlink" href="#哈夫曼树特点" title="Permanent link">&para;</a></h4>
<ul>
<li>每个初始节点最终都成为叶结点</li>
<li>构造过程中新建了<code>n-1</code>个结点，哈夫曼树中结点总数为<code>2n-1</code></li>
<li>不存在度为<code>1</code>的节点</li>
</ul>
<h4 id="哈夫曼编码">哈夫曼编码<a class="headerlink" href="#哈夫曼编码" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>固定长度编码：对每个字符用相等长度的二进制位表示</p>
</li>
<li>
<p>可变长度编码：允许对不同字符用不等长的二进制位表示</p>
</li>
<li>
<p>前缀编码：没有一个编码是另一个编码的前缀</p>
</li>
<li>
<p>使用哈夫曼树得到哈夫曼编码：默认为左边为0，右边为1（不唯一，没明确规定）</p>
</li>
</ul>
<h1 id="图">图<a class="headerlink" href="#图" title="Permanent link">&para;</a></h1>
<h2 id="图的基本概念">图的基本概念<a class="headerlink" href="#图的基本概念" title="Permanent link">&para;</a></h2>
<h3 id="图的定义">图的定义<a class="headerlink" href="#图的定义" title="Permanent link">&para;</a></h3>
<p>图<span class="arithmatex">\(G\)</span>由顶点集<span class="arithmatex">\(V\)</span>和边集<span class="arithmatex">\(E\)</span>组成，记为<span class="arithmatex">\(G=(V,E)\)</span>,其中<span class="arithmatex">\(V(G)\)</span>表示图<span class="arithmatex">\(G\)</span>中顶点的有限非空集；<span class="arithmatex">\(E(G)\)</span>表示图<span class="arithmatex">\(G\)</span>中顶点之间的关系集合。<span class="arithmatex">\(V=\{v_1,v_2,...,v_n\}\)</span>,<span class="arithmatex">\(|V|\)</span>表示顶点个数，<span class="arithmatex">\(E=\{(u,v)|u \in V,v\in V\}\)</span>,<span class="arithmatex">\(|E|\)</span>表示图<span class="arithmatex">\(G\)</span>中边的条数</p>
<h4 id="基本术语_1">基本术语<a class="headerlink" href="#基本术语_1" title="Permanent link">&para;</a></h4>
<ul>
<li>有向图</li>
<li>无向图</li>
<li>简单图、多重图</li>
<li>完全图</li>
<li>子图</li>
<li>连通、连通图和连通分量</li>
<li>强连通图、强连通分量</li>
<li>生成树、生成森林</li>
<li>顶点的度、入度和出度</li>
<li>边的权和网</li>
<li>稠密图、稀疏图</li>
<li>路径、路径长度和回路</li>
<li>简单路径、简单回路</li>
<li>距离</li>
<li>有向树</li>
</ul>
<h2 id="图的存储及基本操作">图的存储及基本操作<a class="headerlink" href="#图的存储及基本操作" title="Permanent link">&para;</a></h2>
<ul>
<li>必须完整、准确地反映顶点集和边集的信息</li>
</ul>
<h3 id="邻接矩阵法">邻接矩阵法<a class="headerlink" href="#邻接矩阵法" title="Permanent link">&para;</a></h3>
<ul>
<li>一个一维数组存储图中顶点的信息</li>
<li>一个二维数组存储图中边的信息，称为<strong>邻接矩阵</strong></li>
<li>设图<span class="arithmatex">\(G\)</span>的邻接矩阵为<span class="arithmatex">\(A\)</span>,<span class="arithmatex">\(A^n\)</span>的元素等于从顶点i到j的长度为n的路径数目</li>
</ul>
<h3 id="邻接表法">邻接表法<a class="headerlink" href="#邻接表法" title="Permanent link">&para;</a></h3>
<ul>
<li>顶点表结点</li>
</ul>
<p>边表的头指针和顶点的数据信息采用顺序存储</p>
<table>
<thead>
<tr>
<th>顶点域</th>
<th>边表头指针</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code>firstarc</code></td>
</tr>
</tbody>
</table>
<ul>
<li>边表结点</li>
</ul>
<p>对每个顶点<span class="arithmatex">\(v_i\)</span>建立一个单链表，第<span class="arithmatex">\(i\)</span>个单链表中的结点表示依附于顶点<span class="arithmatex">\(v_i\)</span>的边，这个单链表为顶点<span class="arithmatex">\(v_i\)</span>的<strong>边表</strong></p>
<table>
<thead>
<tr>
<th>邻接点域</th>
<th>指针域</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>adjvex</code></td>
<td><code>nextarc</code></td>
</tr>
</tbody>
</table>
<ul>
<li>若存储的是无向图,空间复杂度为<span class="arithmatex">\(O(|V|+2|E|)\)</span>；若为有向图，空间复杂度为<span class="arithmatex">\(O(|V|+|E|)\)</span></li>
</ul>
<h3 id="十字链表">十字链表<a class="headerlink" href="#十字链表" title="Permanent link">&para;</a></h3>
<ul>
<li>有向图的一种链式存储结构</li>
<li>对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点</li>
<li>弧结点</li>
</ul>
<table>
<thead>
<tr>
<th>尾域</th>
<th>头域</th>
<th>链域-&gt;弧头相同的下一条弧</th>
<th>链域-&gt;弧尾相同的下一条弧</th>
<th>弧信息</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tailvex</code></td>
<td><code>headvex</code></td>
<td><code>hlink</code></td>
<td><code>tlink</code></td>
<td><code>info</code></td>
</tr>
</tbody>
</table>
<ul>
<li>顶点结点</li>
</ul>
<table>
<thead>
<tr>
<th>数据</th>
<th>第一条出弧</th>
<th>第一条入弧</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code>firstin</code></td>
<td><code>firstout</code></td>
</tr>
</tbody>
</table>
<h3 id="邻接多重表">邻接多重表<a class="headerlink" href="#邻接多重表" title="Permanent link">&para;</a></h3>
<ul>
<li>无向图的链式存储结构</li>
<li>与邻接表的区别是，同一条边在邻接多重表中只有一个结点</li>
<li>边结点</li>
</ul>
<table>
<thead>
<tr>
<th>标志域</th>
<th>依附的结点</th>
<th>下一条依附于<code>ivex</code>的边</th>
<th>依附的结点</th>
<th>下一条依附于<code>jvex</code>的边</th>
<th>边信息</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mark</code></td>
<td><code>ivex</code></td>
<td><code>ilink</code></td>
<td><code>jvex</code></td>
<td><code>jlink</code></td>
<td><code>info</code></td>
</tr>
</tbody>
</table>
<ul>
<li>顶点结点</li>
</ul>
<table>
<thead>
<tr>
<th>数据</th>
<th>第一条依附于该顶点的边</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>data</code></td>
<td><code>firstedge</code></td>
</tr>
</tbody>
</table>
<h3 id="图的基本操作">图的基本操作<a class="headerlink" href="#图的基本操作" title="Permanent link">&para;</a></h3>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">Adjacent</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">判断图G是否存在边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span>
<span class="n">Neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">列出图G中与结点x邻接对的边</span>
<span class="n">InsertVertex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">在图G中插入顶点x</span>
<span class="n">DeleteVertex</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">从图G中删除顶点x</span>
<span class="n">AddEdge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">若边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="n">不存在</span><span class="err">，</span><span class="n">则向图G中添加该边</span>
<span class="n">RemoveEdge</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">若边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="n">存在</span><span class="err">，</span><span class="n">则从图G中删除该边</span>
<span class="n">FirstNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">求图G中顶点x的第一个邻接点</span><span class="err">，</span><span class="n">若有则返回顶点号</span><span class="err">。</span><span class="n">否则返回</span><span class="mi">-1</span>
<span class="n">NextNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">假设图G中顶点y是顶点x的一个邻接点</span><span class="err">，</span><span class="n">返回除y外顶点x的下一个邻接点的顶点号</span><span class="err">，</span><span class="n">若没有返回</span><span class="mi">-1</span>
<span class="n">Get_edge_value</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">获取图G中边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="n">的权值</span>
<span class="n">Set_edge_value</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">:</span><span class="n">设置图G中边</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span><span class="n">对应的权值为v</span>
</code></pre></div></td></tr></table></div>
<h2 id="图的遍历">图的遍历<a class="headerlink" href="#图的遍历" title="Permanent link">&para;</a></h2>
<ul>
<li>图的遍历是从图中某一顶点出发，按照某种搜索方法沿着图中的对边对图中所有顶点访问且只访问一次。</li>
<li>在广度优先搜索和深度优先搜索中，可以将节点的状态分为三种<ul>
<li>白节点：该节点暂未被发现</li>
<li>灰节点：其领接节点中可能存在未被发现的白节点</li>
<li>黑节点：该节点被发现，且其所有领结节点也均被发现</li>
</ul>
</li>
</ul>
<h3 id="广度优先算法">广度优先算法<a class="headerlink" href="#广度优先算法" title="Permanent link">&para;</a></h3>
<p><code>Breadth-Frist-Search,BFS</code></p>
<ul>
<li>基本思想</li>
</ul>
<p>首先访问起始顶点<span class="arithmatex">\(v\)</span>,接着由<span class="arithmatex">\(v\)</span>出发，依次访问v的各个未访问过的邻接顶点<span class="arithmatex">\(w_1,w_2,...,w_i\)</span>,然后一次访问<span class="arithmatex">\(w_1,w_2,...,w_i\)</span>的所有未被访问的邻接顶点。</p>
<p>换句话说，<code>BFS</code>是以<code>v</code>为起始点，由近及远依次访问和<code>v</code>有路径相通且路径长度为1,2,...的顶点</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="n">visited</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span><span class="c1">//访问标记数组</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">BFSTraverse</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">){</span><span class="w">  </span><span class="c1">//对图G进行广度优先遍历</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span>
<span class="w">    </span><span class="n">InitQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w">     </span><span class="c1">//对每个连通分量调用一次BFS</span>
<span class="w">            </span><span class="n">BFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">BFS</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">){</span><span class="c1">//从顶点v出发，广度优先遍历图G</span>
<span class="w">    </span><span class="n">visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="w">    </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">)){</span>
<span class="w">        </span><span class="n">DeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">FirstNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="n">w</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">=</span><span class="n">Neighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]){</span>
<span class="w">                </span><span class="n">visit</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
<span class="w">                </span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="w">                </span><span class="n">EnQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="深度优先搜索">深度优先搜索<a class="headerlink" href="#深度优先搜索" title="Permanent link">&para;</a></h3>
<p><code>Depth-First-Search,DFS</code></p>
<ul>
<li>基本思想</li>
</ul>
<p>首先访问图中某一起始顶点<span class="arithmatex">\(v\)</span>,然后由<span class="arithmatex">\(v\)</span>出发，访问与<span class="arithmatex">\(v\)</span>邻接且未被访问的任一顶点<span class="arithmatex">\(w_1\)</span>,再访问与<span class="arithmatex">\(w_1\)</span>邻接且未被访问的任一顶点，重复上述过程。用<code>v.d</code>记录其成为灰节点的时间，用<code>v.f</code>记录其成为黑节点的时间。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="n">visited</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">DFSTraverse</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">){</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span>
<span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;</span><span class="n">G</span><span class="p">.</span><span class="n">vexnum</span><span class="p">;</span><span class="o">++</span><span class="n">v</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
<span class="w">            </span><span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="w">        </span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">DFS</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">){</span>
<span class="w">    </span><span class="n">visit</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="p">;</span><span class="c1">//the time of became gray</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">FirstNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">);</span><span class="n">w</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">w</span><span class="o">=</span><span class="n">NextNeighbor</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="p">]){</span>
<span class="w">            </span><span class="n">DFS</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span><span class="p">;</span><span class="c1">//the time of became black</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h4 id="深度优先森林">深度优先森林<a class="headerlink" href="#深度优先森林" title="Permanent link">&para;</a></h4>
<p>可以定义4种边的类型
- 树边：为深度优先森林中的边。如果节点<span class="arithmatex">\(v\)</span>是因算法对边<span class="arithmatex">\((u,v)\)</span>的探索而首先被发现，则<span class="arithmatex">\((u,v)\)</span>是一条树边
- 后向边：后向边<span class="arithmatex">\((u,v)\)</span>是将节点<span class="arithmatex">\(u\)</span>连接到其在深度优先树中祖先节点<span class="arithmatex">\(v\)</span>的边。
- 前向边：是将节点<span class="arithmatex">\(u\)</span>连接到其在深度优先树中一个后代节点<span class="arithmatex">\(v\)</span>的边
- 横向边：指其他所有的边。这些边可以连接同一颗深度优先树中的节点，只要其中一个节点不是另一个节点的祖先，也可以连接不同深度优先树中的两个节点
无向图中的边只有树边和后向边之分
<strong>一个有向图是无环的当且仅当在对其进行的深度优先搜索不产生后向边</strong>
<strong>判断边的方法</strong>
在遇到某些边时，DFS有足够的信息来对这些边进行分类。这里的关键是，当第一次探索边<span class="arithmatex">\((u,v)\)</span>时，节点<span class="arithmatex">\(v\)</span>的颜色能够告诉我们关于该边的信息
- 节点v为白色：<span class="arithmatex">\((u,v)\)</span>是一条树边
- 节点v为灰色：<span class="arithmatex">\((u,v)\)</span>是一条后向边
- 节点v为黑色：<span class="arithmatex">\((u,v)\)</span>是一条前向边或横向边</p>
<h3 id="性能">性能<a class="headerlink" href="#性能" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>性能</th>
<th>广度优先搜索/深度优先搜索</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间复杂度</td>
<td><span class="arithmatex">\(O(\mid V \mid)\)</span></td>
</tr>
<tr>
<td>时间复杂度-邻接矩阵</td>
<td><span class="arithmatex">\(O(\mid V\mid^2)\)</span></td>
</tr>
<tr>
<td>时间复杂度-邻接表</td>
<td><span class="arithmatex">\(O(\mid V\mid +\mid E\mid)\)</span></td>
</tr>
<tr>
<td>生成树</td>
<td>广度深度优先生成树，邻接表不唯一，邻接矩阵唯一</td>
</tr>
</tbody>
</table>
<h2 id="图的应用">图的应用<a class="headerlink" href="#图的应用" title="Permanent link">&para;</a></h2>
<h3 id="最小生成树">最小生成树<a class="headerlink" href="#最小生成树" title="Permanent link">&para;</a></h3>
<p>求一个带权连通图的最小生成树<code>Minimum-Spanning-Tree,MST</code></p>
<h4 id="prim算法">Prim算法<a class="headerlink" href="#prim算法" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>基本思想</p>
</li>
<li>
<p>初始时从图中任取一顶点加入树T,此时树中只含有一个顶点</p>
</li>
<li>
<p>之后选择一个与当前T中<strong>顶点集合</strong>距离最近的顶点，且加入后不能出现环，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。</p>
</li>
<li>
<p>重复直到加满</p>
</li>
<li>
<p>时间复杂度：<span class="arithmatex">\(O(|V|^2 )\)</span></p>
</li>
</ul>
<h4 id="kruskal算法">Kruskal算法<a class="headerlink" href="#kruskal算法" title="Permanent link">&para;</a></h4>
<ul>
<li>基本思想</li>
<li>初始时为只有n个顶点而无边的非连通图T，每个顶点自成一个连通分量</li>
<li>按照边的权值由小到大，加入到非连通图T中，不能形成环</li>
<li>重复直到加满</li>
<li>时间复杂度：<span class="arithmatex">\(O(|E|log|E|)\)</span></li>
</ul>
<h3 id="最短路径">最短路径<a class="headerlink" href="#最短路径" title="Permanent link">&para;</a></h3>
<h4 id="bellman-ford算法">Bellman-Ford算法<a class="headerlink" href="#bellman-ford算法" title="Permanent link">&para;</a></h4>
<p>Bellman-Ford算法解决的是一般情况下的单源最短路径问题。边的权重可以为负值。Bellman-Ford算法返回一个布尔值，以表明是否存在一个从源结点可以到达的权重为负值的环路。如果存在，则给出最短路径和他们的权重。
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">InitalizeSingleSource</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
    <span class="c1">#v.d用于记录源结点s到结点v的最短路径的上界/最短路径估计</span>
    <span class="c1">#v.p用于记录结点s到结点v的最短路径中v结点的上一个节点/前驱节点</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">V</span><span class="p">:</span>
        <span class="n">v</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">infty</span>
        <span class="n">v</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">NULL</span>
    <span class="n">s</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">Relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">):</span>
    <span class="c1">#松弛操作，是唯一导致最短路径估计和前驱节点发生变化的操作</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">d</span><span class="o">&gt;</span><span class="n">u</span><span class="o">.</span><span class="n">d</span><span class="o">+</span><span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
        <span class="n">v</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">d</span><span class="o">+</span><span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">v</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">u</span>

<span class="n">BellmanFord</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">s</span><span class="p">)</span><span class="err">：</span>
    <span class="n">InitalizeSingleSource</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="n">to</span> <span class="o">|</span><span class="n">G</span><span class="o">.</span><span class="n">V</span><span class="o">|-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">E</span><span class="err">：</span>
            <span class="n">Relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">E</span><span class="err">：</span>
        <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">d</span><span class="o">&gt;</span><span class="n">u</span><span class="o">.</span><span class="n">d</span><span class="o">+</span><span class="n">w</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="err">：</span>
            <span class="k">return</span> <span class="n">false</span>
    <span class="k">return</span> <span class="n">true</span>
</code></pre></div></td></tr></table></div></p>
<h4 id="有向无环图中的单源最短路径">有向无环图中的单源最短路径<a class="headerlink" href="#有向无环图中的单源最短路径" title="Permanent link">&para;</a></h4>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">DAGShortestPaths</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
    <span class="c1">#首先进行拓扑排序</span>
    <span class="n">topologically</span> <span class="n">sort</span> <span class="n">the</span> <span class="n">vertices</span> <span class="n">of</span> <span class="n">G</span>
    <span class="n">InitializeSingleSource</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">u</span><span class="p">,</span><span class="n">take</span> <span class="ow">in</span> <span class="n">topologically</span> <span class="nb">sorted</span> <span class="n">order</span><span class="p">:</span>
        <span class="c1">#如果存在从节点u到节点v的一条路径</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">Relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
<h4 id="dijkstra算法求单源最短路径">Dijkstra算法求单源最短路径<a class="headerlink" href="#dijkstra算法求单源最短路径" title="Permanent link">&para;</a></h4>
<p>解决的是带权重的有向图上单源最短路径问题，要求所有边的权重都是非负值
- 辅助数组</p>
<ul>
<li>集合<code>S</code>：记录以求得的最短路径的顶点</li>
<li><code>dist[]</code>：记录从源点<span class="arithmatex">\(v_0\)</span>到其他各顶点当前的最短路径长度</li>
<li>
<p><code>path[]</code>：<code>path[i]</code>表示从源点到顶点<span class="arithmatex">\(i\)</span>之间的最短路径的前驱结点。可用于回溯找最短路径</p>
</li>
<li>
<p>算法步骤</p>
</li>
<li>
<p>初始化：集合<code>S</code>初始化为<code>{0}</code>,<code>dist[]</code>的初始值<code>dist[i]=arcs[0][i]</code></p>
</li>
<li>
<p>从顶点集合<code>V-S</code>中选出<span class="arithmatex">\(v_j\)</span>,满足<span class="arithmatex">\(dist[j]=Min\{dist[i] \ |v_i \in V-S\}\)</span>,令<span class="arithmatex">\(S=S\cup\{j\}\)</span></p>
</li>
<li>
<p>根据公式修改从<span class="arithmatex">\(v_0\)</span>出发到集合V-S上任一顶点<span class="arithmatex">\(v_k\)</span>可达的最短路径长度</p>
<p>若<code>dist[j]+arcs[j][k]&lt;dist[k]</code>,则更新</p>
</li>
<li>
<p>重复步骤2-3操作共<code>n-1</code>次</p>
</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">Dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
    <span class="c1">#算法导论中的实现方法</span>
    <span class="n">InitializeSingleSource</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">v</span>
    <span class="k">while</span> <span class="n">Q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="p">{}:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">ExtractMin</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="c1">#用于寻找剩余的顶点中距离最近的顶点</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">+</span><span class="p">{</span><span class="n">u</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">vertex</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">Adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">Relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span> <span class="c1">#对所有能从u发出的路径点进行松弛</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>时间复杂度：<span class="arithmatex">\(O(|V|^2)\)</span></li>
</ul>
<h4 id="floyd算法求个定点之间最短路径">Floyd算法求个定点之间最短路径<a class="headerlink" href="#floyd算法求个定点之间最短路径" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>算法描述</p>
</li>
<li>
<p>定义一个n阶方阵<span class="arithmatex">\(A^{(-1)}，A^{(0)}，...,A^{(n-1)}\)</span>,其中<span class="arithmatex">\(A^{(-1)}[i][j]=arcs[i][j]\)</span>,</p>
</li>
<li>
<p>根据递推公式重复<code>n</code>次，计算出<span class="arithmatex">\(A^{(0)}，...,A^{(n-1)}\)</span></p>
<p><span class="arithmatex">\(A^{(k)}[i][j]=Min\{A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},k=0,1,..,n-1\)</span></p>
<p>其中，<span class="arithmatex">\(A^{(0)}[i][j]\)</span>是从顶点<span class="arithmatex">\(v_i\)</span>到<span class="arithmatex">\(v_j\)</span>、中间路径是<span class="arithmatex">\(v_0\)</span>的最短路径的长度，<span class="arithmatex">\(A^{(k)}[i][j]\)</span>是从顶点<span class="arithmatex">\(v_i\)</span>到<span class="arithmatex">\(v_j\)</span>、中间顶点的序号不大于k的最短路径的长度</p>
</li>
<li>
<p>时间复杂度<span class="arithmatex">\(O(|V|^3)\)</span></p>
</li>
</ul>
<h3 id="有向无环图描述表达式">有向无环图描述表达式<a class="headerlink" href="#有向无环图描述表达式" title="Permanent link">&para;</a></h3>
<p>有向无环图<code>DAG</code></p>
<p>有向无环图是描述含有公共子式的表达式的有效工具，可实现对相同子式的共享，从而节省存储空间</p>
<h3 id="拓扑排序">拓扑排序<a class="headerlink" href="#拓扑排序" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p><code>AOV网</code>：若用<code>AVG</code>表示一个工程，其顶点表示活动，用有向边<span class="arithmatex">\(&lt;V_i,V_j&gt;\)</span>表示活动<span class="arithmatex">\(V_i\)</span>必须先于活动<span class="arithmatex">\(V_j\)</span>进行的这样一种关系，则将这种有向图称为<strong>顶点表示活动的网络</strong></p>
</li>
<li>
<p>拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序</p>
</li>
<li>每个顶点出现且只出现一次</li>
<li>若顶点<code>A</code>在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径</li>
<li>拓扑排序算法</li>
<li>从<code>AOV</code>网中选择一个没有前驱的顶点并输出</li>
<li>从网中删除该顶点和所有以它为起点的有向边</li>
<li>重复1-2，直到当前<code>AOV</code>网为空<ul>
<li>还有一种算法是将其按照深度优先搜索中的<code>v.f</code>大小按逆序排序，就是其拓扑排序</li>
</ul>
</li>
<li>时间复杂度<span class="arithmatex">\(O(|V|+|E|)\)</span></li>
<li>逆拓扑排序</li>
<li>从<code>AOV</code>网中选择一个没有后继的顶点并输出</li>
<li>从网中删除该顶点和所有以它为重点的有向边</li>
<li>重复1-2直到<code>AOV</code>为空</li>
</ul>
<h3 id="关键路径">关键路径<a class="headerlink" href="#关键路径" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为<strong>用边表示活动的网络</strong>，简称<code>AOE网</code></p>
</li>
<li>
<p><code>AOE网</code>中仅有一个入度为0的顶点，称为开始顶点（源点）；只存在一个出度为0的顶点，称之为结束顶点（汇点）</p>
</li>
<li>
<p>具有最大路径长度的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong></p>
</li>
<li>
<p>关键路径并不唯一，只提高其中一条关键路径上的关键活动速度不能缩短整个工程的工期。</p>
</li>
<li>
<p>计算参数</p>
</li>
<li>
<p><strong>事件<span class="arithmatex">\(v_k\)</span>的最早发生时间<span class="arithmatex">\(ve(k)\)</span></strong></p>
<ul>
<li><span class="arithmatex">\(ve(源点)=0\)</span></li>
<li><span class="arithmatex">\(ve(k)=Max\{ve(j)+Weight(v_j,v_k\}\)</span></li>
<li>按拓扑排序，依次计算</li>
</ul>
</li>
<li>
<p><strong>事件<span class="arithmatex">\(v_k\)</span>的最迟发生时间<span class="arithmatex">\(vl(k)\)</span></strong></p>
</li>
<li>
<p><span class="arithmatex">\(vl(汇点)=ve(汇点)\)</span></p>
<ul>
<li><span class="arithmatex">\(vl(k)=Min\{vl(j)-Weight(v_k,v_j\}\)</span></li>
<li>按逆拓扑排序依次计算</li>
</ul>
</li>
<li>
<p><strong>活动<span class="arithmatex">\(a_i\)</span>的最早开始时间<span class="arithmatex">\(e(i)\)</span></strong></p>
</li>
<li>它是指该活动弧的起点所表示的事件最早发生时间。<ul>
<li>若边<span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span>表示活动<span class="arithmatex">\(a_i\)</span>,则有<span class="arithmatex">\(e(i)=ve(k)\)</span></li>
</ul>
</li>
<li>
<p><strong>活动<span class="arithmatex">\(a_i\)</span>的最迟开始时间<span class="arithmatex">\(l(i)\)</span></strong></p>
</li>
<li>
<p>它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差</p>
<ul>
<li>若边<span class="arithmatex">\(&lt;v_k,v_j&gt;\)</span>表示活动<span class="arithmatex">\(a_i\)</span>,则有<span class="arithmatex">\(l(i)=vl(j)-Weight(v_k,v_j)\)</span></li>
</ul>
</li>
<li>
<p>一个活动<span class="arithmatex">\(a_i\)</span>的最迟开始时间<span class="arithmatex">\(l(i)\)</span>和其最早开始时间<span class="arithmatex">\(e(i)\)</span>的差额<span class="arithmatex">\(d(i)=l(i)-e(i)\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(d(i)=0\)</span>++的活动<span class="arithmatex">\(a_i\)</span>是关键活动</p>
</li>
</ul>
<h3 id="强连通分量">强连通分量<a class="headerlink" href="#强连通分量" title="Permanent link">&para;</a></h3>
<p>将一个有向图分解为若干个强连通分量。称为分量图<code>G^{SCC}=(V^{SCC},E^{SCC})</code>。
- 分量图中的每个节点是一个强联通分量，里面的所有子节点都可以代表该连通分量
- 分量图是一个有向无环图</p>
<ul>
<li>求分量图的分解算法，其中用到了图<span class="arithmatex">\(G\)</span>的转置<span class="arithmatex">\(G^T\)</span>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">StronglyConnectedComponents</span><span class="p">(</span><span class="n">G</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//call DFS(G) to compute finishing time u.f for each vertex u</span>
<span class="w">    </span><span class="c1">//compute G^T</span>
<span class="w">    </span><span class="c1">//call DFS(G^T),but in the main loop of DFS,consider the vertices in order of decreasing u.f(按照上一次DFS中完成时间的逆序来搜索)</span>
<span class="w">    </span><span class="c1">//output the vertices of each tree in the depth-first forest formed in line3 as a separate strongly connected component</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div></li>
</ul>
<h3 id="最大流">最大流<a class="headerlink" href="#最大流" title="Permanent link">&para;</a></h3>
<p>将一个有向图看成一个流网络并使用它来回答关于物料流动方面的问题。设想一种物料从产生它的源节点经过一个系统，流向消耗该物料的汇点的一个过程。源节点以某种稳定的速率生成物料，汇点则以同样的速率消耗物料。</p>
<h4 id="流网络">流网络<a class="headerlink" href="#流网络" title="Permanent link">&para;</a></h4>
<h5 id="流网络_1">流网络<a class="headerlink" href="#流网络_1" title="Permanent link">&para;</a></h5>
<ul>
<li>流网络<span class="arithmatex">\(G(V,E)\)</span>是一个有向图，图中每条边<span class="arithmatex">\((u,v)\in E\)</span>有一个非负的容量值<span class="arithmatex">\(c(u,v) \geq 0\)</span>。</li>
<li>而且，如果边集合<span class="arithmatex">\(E\)</span>包含一条边<span class="arithmatex">\((u,v)\)</span>，则图中不存在反向的边<span class="arithmatex">\((v,u)\)</span>。</li>
<li>
<p>存在源节点<span class="arithmatex">\(s\)</span>和汇点<span class="arithmatex">\(t\)</span>。</p>
</li>
<li>
<p>假定每个结点都在从源节点到汇点的某条路径上。</p>
</li>
</ul>
<h5 id="流">流<a class="headerlink" href="#流" title="Permanent link">&para;</a></h5>
<p>设<span class="arithmatex">\(G=(V,E)\)</span>为一个流网络，其容量函数为<span class="arithmatex">\(c\)</span>。设s为网络的源节点，t为汇点。G中的流是一个实值函数<span class="arithmatex">\(f\)</span>，满足下面的性质：</p>
<ul>
<li>容量限制：从一个结点到另一个结点之间的流必须为非负值且不能超过给定的容量限额</li>
</ul>
<div class="arithmatex">\[
对于所有结点u,v\in V,0 \leq f(u,v) \leq c(u,v) \tag{容量限制}
\]</div>
<ul>
<li>流量守恒：流入一个结点的总流量必须等于流出某个节点的总流量</li>
</ul>
<div class="arithmatex">\[
对于所有的结点u \in V-\{s,t\},要求 \sum_{v\in V}f(v,u) = \sum_{v \in V}f(u,v)\tag{流量守恒}
\]</div>
<ul>
<li>流的计算公式是：从源节点流出的总流量减去流入源节点的总流量</li>
</ul>
<div class="arithmatex">\[
|f| = \sum_{v \in V}f(s,v) - \sum_{v\in V}f(v,s)    \tag{流的定义}
\]</div>
<h5 id="特殊情况处理">特殊情况处理<a class="headerlink" href="#特殊情况处理" title="Permanent link">&para;</a></h5>
<ul>
<li>使用反平行边来模拟问题：当图中某条边存在反向边，可以通过增加一个虚拟中间结点作为过渡，消除反平行边</li>
<li>具有多个源节点和多个汇点的网络：加入一个超级源节点和超级汇点，超级源节点到源节点的容量为无穷大，汇点到超级汇点的容量为无穷大</li>
</ul>
<h4 id="ford-fulkerson方法">Ford-Fulkerson方法<a class="headerlink" href="#ford-fulkerson方法" title="Permanent link">&para;</a></h4>
<p>Ford-Fulkerson方法循环增加流的值。在开始的时候，对于所有的结点<span class="arithmatex">\(u,v\in V,f(u, v)=0\)</span>，给出的初始流值为0。</p>
<p>在每一次迭代中，我们将图G的流值进行增加，方法就是在一个关联的“残存网络”<span class="arithmatex">\(G_f\)</span>中寻找一条“增广 路径”。一 旦知道图<span class="arithmatex">\(G_f\)</span>中一条增广 路径的边，就可以很容易辨别出<span class="arithmatex">\(G\)</span>中的一些 具体的边，我们可以对这些边上的流量进行修改，从而增加流的值。虽然Ford Fulkerson方法的每次迭代都增加流的值，但是对于图G的一条特定边来说，其流量可能增加，也可能减少；对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。重复对流进行这一过程， 直到残存网络中不再存在增广路径为止。最大流最小切割定理将说明在算法终结时，该算法将获得一个最大流。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">FordFulkersonMethod</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">initalize</span> <span class="n">f</span> <span class="n">to</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">there</span> <span class="n">exists</span> <span class="n">an</span> <span class="n">augmenting</span> <span class="n">path</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">rasidual</span> <span class="n">network</span> <span class="n">G_f</span><span class="p">:</span>
        <span class="n">augment</span> <span class="n">flow</span> <span class="n">f</span> <span class="n">along</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">f</span>
</code></pre></div></td></tr></table></div>
<h5 id="残存网络">残存网络<a class="headerlink" href="#残存网络" title="Permanent link">&para;</a></h5>
<p>给定流网络G和流量f，残存网络<span class="arithmatex">\(G_f\)</span>由那些仍有空间对流量进行调整的边构成。注意残存网络中可能包含图<span class="arithmatex">\(G\)</span>中不存在的边，如残存容量的第二种情况。</p>
<ul>
<li>残存容量<span class="arithmatex">\(c_f\)</span>设置为</li>
</ul>
<div class="arithmatex">\[
c_f(u,v) = 
\begin{cases}
c(u,v)-f(u,v) &amp;(u,v)\in E\\
f(v,u) &amp;(v,u) \in E\\
0 &amp;else
\end{cases}
\]</div>
<ul>
<li>
<p>残存网络<span class="arithmatex">\(G_f=(V,E_f)\)</span>定义为：<span class="arithmatex">\(E_f=\{(u,v) \in V \times V:c_f(u,v)&gt;0\}\)</span></p>
</li>
<li>
<p>递增公式<code>augmentation</code></p>
</li>
</ul>
<p>递增公式用于在原来的流网络中增加流。假设f是G中的一个流，<span class="arithmatex">\(f'\)</span>是对应的残存网络中的一个流，定义<span class="arithmatex">\(f\uparrow f'\)</span>为流<span class="arithmatex">\(f'\)</span>对流<span class="arithmatex">\(f\)</span>的递增</p>
<div class="arithmatex">\[
  (f\uparrow f')(u,v) = 
  \begin{cases}
  f(u,v)+f'(u,v)-f'(v,u)&amp;(u,v)\in E\\
  0 &amp;else
  \end{cases}
\]</div>
<p><span class="arithmatex">\(|f \uparrow f'| = |f|+|f'|\)</span></p>
<h5 id="增广路径">增广路径<a class="headerlink" href="#增广路径" title="Permanent link">&para;</a></h5>
<p>增广路径<span class="arithmatex">\(p\)</span>是残存网络<span class="arithmatex">\(G_f\)</span>中一条从源节点到汇点的简单路径。对于一条增广路径上的边<span class="arithmatex">\((u,v)\)</span>，我们可以增加其流量的幅度最大为<span class="arithmatex">\(c_f(u,v)\)</span>，而不会违反<span class="arithmatex">\((u,v)\)</span>或<span class="arithmatex">\((v,u)\)</span>的容量限制。我们称一条增广路径<span class="arithmatex">\(p\)</span>上能够为每条边增加的流量的最大值为路径<span class="arithmatex">\(p\)</span>的<strong>残存容量</strong></p>
<div class="arithmatex">\[
c_f(p) = min\{c_f(u,v):(u,v)\in p \}
\]</div>
<p>如果将流增加<span class="arithmatex">\(c_f(p)\)</span>，将获得另一个流，该流的值更加接近最大值</p>
<h5 id="流网络的切割">流网络的切割<a class="headerlink" href="#流网络的切割" title="Permanent link">&para;</a></h5>
<p>流网络<span class="arithmatex">\(G=(V,E)\)</span>的一个切割<span class="arithmatex">\((S,T)\)</span>将结点集合<span class="arithmatex">\(V\)</span>划分成<span class="arithmatex">\(S\)</span>和<span class="arithmatex">\(T=V-S\)</span>两个集合。</p>
<ul>
<li>切割<span class="arithmatex">\((S,T)\)</span>的净流量<span class="arithmatex">\(f(S,T)\)</span></li>
</ul>
<div class="arithmatex">\[
f(S,T) = \sum_{u\in S}\sum_{v\in T}f(u,v)-\sum_{u\in S}\sum_{v\in T}f(v,u)
\]</div>
<ul>
<li>切割<span class="arithmatex">\((S,T)\)</span>的容量是</li>
</ul>
<div class="arithmatex">\[
  c(S,T) = \sum_{u\in S}\sum_{v\in T}c(u,v)
\]</div>
<p>横跨任何切割的净流量都相同，都等于<span class="arithmatex">\(|f|\)</span>，即流的值。流网络<span class="arithmatex">\(G\)</span>中任意流<span class="arithmatex">\(f\)</span>的值不能超过<span class="arithmatex">\(G\)</span>的任何切割的容量</p>
<h5 id="最大流最小切割定理">最大流最小切割定理<a class="headerlink" href="#最大流最小切割定理" title="Permanent link">&para;</a></h5>
<p>下面的条件是等价的</p>
<ul>
<li><span class="arithmatex">\(f\)</span>是<span class="arithmatex">\(G\)</span>的一个最大流</li>
<li>残存网络<span class="arithmatex">\(G_f\)</span>不包含任何增广路径</li>
<li><span class="arithmatex">\(|f|=c(S,T)\)</span>，其中<span class="arithmatex">\((S,T)\)</span>是流网络<span class="arithmatex">\(G\)</span>的某个切割</li>
</ul>
<h5 id="基本的ford-fulkerson算法">基本的Ford-Fulkerson算法<a class="headerlink" href="#基本的ford-fulkerson算法" title="Permanent link">&para;</a></h5>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">FordFulkerson</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>   
    <span class="k">for</span> <span class="n">each</span> <span class="n">eage</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">E</span><span class="p">:</span>
        <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">there</span> <span class="n">exists</span> <span class="n">a</span> <span class="n">path</span> <span class="n">p</span> <span class="kn">from</span> <span class="nn">s</span> <span class="n">to</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">residual</span> <span class="n">network</span> <span class="n">G_f</span><span class="p">:</span>
        <span class="n">c_f</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="nb">min</span><span class="p">{</span><span class="n">c_f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">p</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">each</span> <span class="n">edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">E</span><span class="p">:</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">f</span> <span class="o">+</span> <span class="n">c_f</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">f</span> <span class="o">-</span> <span class="n">c_f</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
<h4 id="最大二分匹配">最大二分匹配<a class="headerlink" href="#最大二分匹配" title="Permanent link">&para;</a></h4>
<h5 id="最大二分匹配问题">最大二分匹配问题<a class="headerlink" href="#最大二分匹配问题" title="Permanent link">&para;</a></h5>
<p>给定一个无向图<span class="arithmatex">\(G=(V,E)\)</span>，一个匹配是边的一个子集<span class="arithmatex">\(M \subseteq E\)</span>，使得对于所有结点<span class="arithmatex">\(v\in V\)</span>，子集<span class="arithmatex">\(M\)</span>中最多有一条边与结点<span class="arithmatex">\(v\)</span>相连，则称结点<span class="arithmatex">\(v\)</span>由<span class="arithmatex">\(M\)</span>所<strong>匹配</strong>。在一个二分图中，结点集可以分为<span class="arithmatex">\(V=L \cup R\)</span>，其中<span class="arithmatex">\(L\)</span>和<span class="arithmatex">\(R\)</span>是不相交的，并且边集合<span class="arithmatex">\(E\)</span>中的所有边横跨<span class="arithmatex">\(L\)</span>和<span class="arithmatex">\(R\)</span>。</p>
<h5 id="寻找最大二分匹配">寻找最大二分匹配<a class="headerlink" href="#寻找最大二分匹配" title="Permanent link">&para;</a></h5>
<p>构造最大流问题与最大二分匹配的关系。可以构造一个流网络<span class="arithmatex">\(G'=(V',E')\)</span>。</p>
<ul>
<li>
<p><span class="arithmatex">\(V'=V \cup \{s,t\}\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(E'=\{(s,u):u\in L\} \cup \{(u,v):(u,v)\in E\} \cup \{(v,t):v\in R\}\)</span> </p>
</li>
<li><span class="arithmatex">\(c(u,v) = 1\)</span></li>
</ul>
<h5 id="增广路径_1">增广路径<a class="headerlink" href="#增广路径_1" title="Permanent link">&para;</a></h5>
<h5 id="流网络的切割_1">流网络的切割<a class="headerlink" href="#流网络的切割_1" title="Permanent link">&para;</a></h5>
<h1 id="查找">查找<a class="headerlink" href="#查找" title="Permanent link">&para;</a></h1>
<h2 id="查找的概念">查找的概念<a class="headerlink" href="#查找的概念" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>查找</strong>：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果分为<strong>成功</strong>和<strong>失败</strong></li>
<li><strong>查找表</strong>：用于查找的数据集合称为查找表。对查找表进行的操作一般有四种</li>
<li>查询</li>
<li>查询关键字的其他信息</li>
<li>插入</li>
<li>删除</li>
<li>静态查找表：不涉及插入和删除的查找表</li>
<li>关键字：数据元素中唯一标识该元素的某个数据项的值</li>
<li>平均查找长度：<span class="arithmatex">\(ASL=\sum_{i=1}^nP_iC_i\)</span>,<span class="arithmatex">\(P_i\)</span>是概率，<span class="arithmatex">\(C_i\)</span>是比较次数</li>
</ul>
<h2 id="顺序查找和折半查找">顺序查找和折半查找<a class="headerlink" href="#顺序查找和折半查找" title="Permanent link">&para;</a></h2>
<h3 id="顺序查找">顺序查找<a class="headerlink" href="#顺序查找" title="Permanent link">&para;</a></h3>
<h4 id="一般线性表的顺序查找">一般线性表的顺序查找<a class="headerlink" href="#一般线性表的顺序查找" title="Permanent link">&para;</a></h4>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="o">*</span><span class="n">elem</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">TableLen</span><span class="p">;</span>
<span class="p">}</span><span class="n">SSTable</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Search_Seq</span><span class="p">(</span><span class="n">SSTable</span><span class="w"> </span><span class="n">ST</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">key</span><span class="p">){</span>
<span class="w">    </span><span class="n">ST</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w">   </span><span class="c1">//哨兵</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">ST</span><span class="o">&gt;</span><span class="n">TableLen</span><span class="p">;</span><span class="n">ST</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">key</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">//从后往前找</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="c1">//若表中不存在关键字为key的元素，将查找到i为0时退出循环</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>哨兵：引入它的目的是可以不必判断数组是否会越界。引入哨兵可以避免很多不必要的判断语句，从而提高程序效率</li>
</ul>
<h4 id="有序表的顺序查找">有序表的顺序查找<a class="headerlink" href="#有序表的顺序查找" title="Permanent link">&para;</a></h4>
<ul>
<li>由于表的关键字是有序的，查找失败时可以不用比较到表的另一端就能返回失败信息</li>
</ul>
<h3 id="折半查找">折半查找<a class="headerlink" href="#折半查找" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>折半查找又称二分查找，仅适用于有序的顺序表</p>
</li>
<li>
<p>仅适用于顺序存储结构，不适用于链式存储结构</p>
</li>
<li>
<p>生成的<strong>判定树</strong></p>
</li>
<li>
<p>是平衡二叉树</p>
</li>
<li>有n个圆形结点代表原数据或成功结点，n+1个方框结点代表不成功结点</li>
<li>每个圆形结点都不是叶子结点，一定有方框子结点</li>
<li>倒数第二层圆结点个数=<span class="arithmatex">\(n-前面层所有结点数\)</span></li>
<li>倒数第二层方形结点个数=<span class="arithmatex">\(2^{h-1}-倒数第二层圆结点\)</span>，最后一层方结点个数=<span class="arithmatex">\(n+1-倒数第二层方形结点个数\)</span></li>
<li>
<p>如果判定树是向上取整，则所有结点的左子树结点总数永远不小于右子树结点整数，向下取整同理</p>
</li>
<li>
<p>基本思想</p>
</li>
</ul>
<p>首先将给定的<code>key</code>与表的中间位置的关键字比较，成功后返回；否则根据<code>key</code>与关键字的大小判断查找左边还是右边</p>
<p>折半查找整个算法中，关于mid的取值向上/向下需要统一</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">Binary_Search</span><span class="p">(</span><span class="n">SeqList</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="n">ElemType</span><span class="w"> </span><span class="n">key</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">high</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">TableLen</span><span class="mi">-1</span><span class="p">,</span><span class="n">mid</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">){</span>
<span class="w">        </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="w">     </span><span class="c1">//取中间位置</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">==</span><span class="n">key</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">mid</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&gt;</span><span class="n">key</span><span class="p">)</span>
<span class="w">            </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="mi">-1</span><span class="p">;</span><span class="c1">//从前半部分继续查找</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="c1">//从后半部分继续查找</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">      </span><span class="c1">//查找失败，返回-1</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="分块查找">分块查找<a class="headerlink" href="#分块查找" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适合快速查找</p>
</li>
<li>
<p>基本思想</p>
</li>
</ul>
<p>将查找表分成若干块。块内的元素可以是无序的。但块之间按照每个块的最大关键字进行排序</p>
<p>建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块的第一个元素的地址，索引表按关键字有序排列</p>
<ul>
<li>分块查找的过程</li>
<li>在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表</li>
<li>
<p>在块内顺序查找</p>
</li>
<li>
<p>索引查找的平均查找长度<span class="arithmatex">\(L_I\)</span>,块内查找的平均查找长度<span class="arithmatex">\(L_S\)</span></p>
</li>
</ul>
<h3 id="时间复杂度评价">时间复杂度评价<a class="headerlink" href="#时间复杂度评价" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>查找算法</th>
<th><span class="arithmatex">\(ASL_{成功}\)</span></th>
<th><span class="arithmatex">\(ASL_{失败}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序查找-无序表</td>
<td><span class="arithmatex">\(\frac{n+1}{2}\)</span></td>
<td><span class="arithmatex">\(n+1\)</span></td>
</tr>
<tr>
<td>顺序查找-有序表</td>
<td><span class="arithmatex">\(\frac{n+1}{2}\)</span></td>
<td><span class="arithmatex">\(\frac n2+\frac n{n+1}\)</span></td>
</tr>
<tr>
<td>折半查找</td>
<td><span class="arithmatex">\(sum(圆形结点*对应层数)/n\)</span></td>
<td><span class="arithmatex">\(sum(方结点*对应层数-1)/(n+1)\)</span></td>
</tr>
<tr>
<td>分块查找</td>
<td><span class="arithmatex">\(ASL=L_I+L_S\)</span></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="b树和b树">B树和B+树<a class="headerlink" href="#b树和b树" title="Permanent link">&para;</a></h2>
<h3 id="b树及其基本操作">B树及其基本操作<a class="headerlink" href="#b树及其基本操作" title="Permanent link">&para;</a></h3>
<p>B树又称<strong>多路平衡查找树</strong>，B树中所有结点的孩子个数的最大值称为B树的阶，通常用<code>m</code>表示。</p>
<h4 id="定义_3">定义<a class="headerlink" href="#定义_3" title="Permanent link">&para;</a></h4>
<ul>
<li>每个结点<code>x</code>有下面属性<ul>
<li>x.n，当前存储在节点x中的关键字个数</li>
<li><code>x.n</code>个关键字本身<span class="arithmatex">\(x.key_i\)</span></li>
<li><code>x.leaf</code>，一个布尔值，如果<code>x</code>是叶节点，则为<code>TRUE</code>，否则为<code>FALSE</code> </li>
</ul>
</li>
<li>每个内部节点<code>x</code>还包含<code>x.n+1</code>个指向其孩子的指针<span class="arithmatex">\(x.c_i\)</span></li>
<li>关键字<span class="arithmatex">\(x.key_i\)</span>对存储在各子树中的关键字范围加以分割：如果<span class="arithmatex">\(k_i\)</span>为任意一个存储在以<span class="arithmatex">\(x.c_i\)</span>为根的子树中的关键字，那么
<span class="arithmatex">\(<span class="arithmatex">\(k_1 \leq x.key_1 \leq k_2 \leq x.key_2 \leq \cdots \leq x.key_{x.n} \leq k_{x.n+1}\)</span>\)</span></li>
<li>每个叶节点具有相同的深度，即树的高度<span class="arithmatex">\(h\)</span></li>
<li>每个节点所包含的关键字个数有上界和下界。用一个被称为B树的<strong>最小度数</strong>的固定整数<span class="arithmatex">\(t \geq 2\)</span>来表示这些界<ul>
<li>除了根结点以外的每个节点必须至少有<span class="arithmatex">\(t-1\)</span>哥个关键字。因此，除了根结点以外的每个内部节点至少有<span class="arithmatex">\(t\)</span>个孩子。如果树为空，根结点至少有一个关键字。</li>
<li>每个节点至多可包含<span class="arithmatex">\(2t-1\)</span>个关键字。因此，一个内部节点至多有<span class="arithmatex">\(2t\)</span>个孩子。当一个节点恰好有<span class="arithmatex">\(2t-1\)</span>个关键字时，称该节点时满的</li>
</ul>
</li>
</ul>
<p>所有非叶子结点的结构如下</p>
<table>
<thead>
<tr>
<th>n</th>
<th><span class="arithmatex">\(P_0\)</span></th>
<th><span class="arithmatex">\(K_1\)</span></th>
<th><span class="arithmatex">\(P_1\)</span></th>
<th><span class="arithmatex">\(K_2\)</span></th>
<th><span class="arithmatex">\(P_2\)</span></th>
<th><span class="arithmatex">\(...\)</span></th>
<th><span class="arithmatex">\(K_n\)</span></th>
<th><span class="arithmatex">\(P_n\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>​   其中，<span class="arithmatex">\(K_i\)</span>为结点的关键字，<span class="arithmatex">\(P_i\)</span>为指向子树根结点的指针，且指针<span class="arithmatex">\(P_{k-1}\)</span>所指子树中所有结点的关键字均小于<span class="arithmatex">\(K_i\)</span>，<span class="arithmatex">\(P_i\)</span>所指子树中所有结点的关键字均大于<span class="arithmatex">\(K_i\)</span></p>
<ul>
<li>所有的叶节点都出现在同一层次上，并且不带信息，称为外部结点</li>
</ul>
<p>B树是所有结点的平衡因子都等于0的多路平衡查找树</p>
<h4 id="b树的高度">B树的高度<a class="headerlink" href="#b树的高度" title="Permanent link">&para;</a></h4>
<p>不包含外部节点那一层</p>
<p><span class="arithmatex">\(h \leq \log_{t} {\frac{n+1}2}\)</span></p>
<h4 id="b树的查找">B树的查找<a class="headerlink" href="#b树的查找" title="Permanent link">&para;</a></h4>
<ul>
<li>在B树中找结点，在磁盘中进行</li>
<li>在结点在找关键字，在内存中进行</li>
</ul>
<h4 id="b树的插入">B树的插入<a class="headerlink" href="#b树的插入" title="Permanent link">&para;</a></h4>
<ol>
<li>定位：利用B树的查找算法，找出插入该关键字的最低层中的某个非叶结点</li>
<li>插入：在B树中，每个内部结点的关键字个数都在区间<span class="arithmatex">\([t-1,2t-1]\)</span>内。插入后的结点关键字个数小于<code>2t-1</code>，可以直接插入。如果插入后关键字个数大于<code>2t-1</code>,必须进行分裂</li>
<li>分裂方法是<ul>
<li>将一个满的节点y按其中间关键子<span class="arithmatex">\(y.key_t\)</span>分裂为两个各含<code>t-1</code>个关键字的节点</li>
<li>左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中</li>
<li>中间位置的节点<span class="arithmatex">\(y.key_t\)</span>插入原节点的父节点</li>
<li>若此时导致父节点也超过了上限，则对父节点继续分裂</li>
</ul>
</li>
</ol>
<h4 id="b树的删除">B树的删除<a class="headerlink" href="#b树的删除" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>当被删关键字<code>k</code><strong>不在终端结点</strong>时，可以用<code>k</code>的前驱或后继<code>k'</code>替代<code>k</code>,然后在相应的结点中删除<code>k'</code>。关键字<code>k'</code>必定落在某个终端节点中，则转换成了被删关键字在终端结点中的情形</p>
</li>
<li>
<p>当被删关键字<code>k</code><strong>在终端结点</strong>中时</p>
</li>
<li>
<p><strong>直接删除关键字</strong>：若被删除关键字所在结点的关键字个数为<span class="arithmatex">\(t\)</span>,表明删除该关键字后仍满足B树的定义，则直接删除该关键字</p>
</li>
<li>
<p><strong>兄弟够借</strong>：若被删除关键字所在结点的关键字个数<span class="arithmatex">\(=t-1\)</span>,且与此节点相邻的右（左）兄弟节点的关键字个数<span class="arithmatex">\(\geq t\)</span>,则需要调整该节点、右（左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡</p>
</li>
<li>
<p><strong>兄弟不够借</strong>：若被删除关键字所在结点的关键字个数<span class="arithmatex">\(=t-1\)</span>,且与此节点相邻的右（左）兄弟节点的关键字个数均为<span class="arithmatex">\(t-1\)</span>,则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。</p>
<p>在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0，则直接将根结点删除，合并后的新结点成为根；若其双亲结点不是根结点，且关键字减少超过下限，在继续合并操作。</p>
</li>
</ul>
<h3 id="b树的基本概念">B+树的基本概念<a class="headerlink" href="#b树的基本概念" title="Permanent link">&para;</a></h3>
<ul>
<li>每个分支结点最多有m棵子树</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有<span class="arithmatex">\(\lceil m/2 \rceil\)</span>棵子树</li>
<li>结点的子树个数与关键字个数相等</li>
<li>所有叶结点包含全部关键字及指向相应记录的指针，叶节点中将关键字按大小顺序排雷，并且相邻叶节点按大小顺序相互链接起来</li>
<li>所有分支结点中仅包含它的各个子节点中关键字的最大值及指向其子结点的指针</li>
</ul>
<p>在B+树中查找时，非叶结点上的关键字值等于查找值时并不停止，而是继续往下找，直到叶结点上的该关键字为止。无论成功与否，每次查找都是一条从根结点到叶结点的路径</p>
<h3 id="b树vsb树">B树VSB+树<a class="headerlink" href="#b树vsb树" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th></th>
<th>B树</th>
<th>B+树</th>
</tr>
</thead>
<tbody>
<tr>
<td>关键字个数为n的结点的子树个数</td>
<td>n-1</td>
<td>n</td>
</tr>
<tr>
<td>结点关键字个数n范围</td>
<td><span class="arithmatex">\(\lceil m/2 \rceil \leq n \leq m\)</span></td>
<td><span class="arithmatex">\(\lceil m/2 \rceil -1\leq n \leq m -1\)</span></td>
</tr>
<tr>
<td></td>
<td></td>
<td>叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址</td>
</tr>
<tr>
<td></td>
<td>叶结点包含的关键字和其他结点包含的关键字是不重复的</td>
<td>叶节点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中</td>
</tr>
</tbody>
</table>
<h2 id="红黑树">红黑树<a class="headerlink" href="#红黑树" title="Permanent link">&para;</a></h2>
<h3 id="基本性质">基本性质<a class="headerlink" href="#基本性质" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>每个结点或是红色的，或是黑色的</p>
</li>
<li>
<p>根结点是黑色的</p>
</li>
<li>
<p>每个叶结点是黑色的</p>
</li>
<li>
<p>如果一个结点是红色的，则它的两个子结点都是黑色的</p>
</li>
<li>对每个结点，从该节点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点</li>
</ol>
<h3 id="性质">性质<a class="headerlink" href="#性质" title="Permanent link">&para;</a></h3>
<ul>
<li>结点有5个属性：<code>color</code>、<code>key</code>、<code>left</code>、<code>right</code>、<code>p</code></li>
<li>从某个节点<code>x</code>出发到达一个叶结点的任意一条简单路径上的黑色结点个数称为该节点的<strong>黑高</strong><code>black-height</code>,记为<code>bh(x)</code></li>
<li>一颗有<code>n</code>个内部结点的红黑树的高度至多为<span class="arithmatex">\(2\lg(n+1)\)</span></li>
<li>红黑树是一种近似平衡的搜索树，可以保证在最坏情况下基本动态集合操作的时间复杂度为<span class="arithmatex">\(O(\lg n)\)</span></li>
<li>使用黑色哨兵结点<code>T.nil</code>用来简化代码，这样原来的所有叶结点都是红色的，其孩子结点均指向哨兵结点</li>
</ul>
<h3 id="插入">插入<a class="headerlink" href="#插入" title="Permanent link">&para;</a></h3>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">RB_Insert</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="n">RBNode</span><span class="w"> </span><span class="n">z</span><span class="p">){</span><span class="c1">//向红黑树T插入一个结点z</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">nil</span><span class="p">;</span><span class="w">      </span><span class="c1">//记录x的前驱</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">;</span><span class="w">     </span><span class="c1">//遍历结点，从根结点开始，寻找插入的位置</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">nil</span><span class="p">)</span><span class="w"> </span><span class="p">){</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">key</span><span class="o">&lt;</span><span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//根据y的情况确定z是y的左孩子还是右孩子</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">nil</span><span class="p">)</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">key</span><span class="o">&lt;</span><span class="n">y</span><span class="p">.</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="n">z</span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">nil</span><span class="p">;</span><span class="w"> </span><span class="c1">//保持树叶结点的合理结构</span>
<span class="w">    </span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">nil</span><span class="p">;</span>
<span class="w">    </span><span class="n">z</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span><span class="w">  </span><span class="c1">//将插入的结点涂为红色</span>
<span class="w">    </span><span class="c1">//对插入后可能违反红黑树性质的情况进行修复</span>
<span class="w">    </span><span class="n">RB_Insert_FixUp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">RB_Insert_FixUp</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="n">RBNode</span><span class="w"> </span><span class="n">z</span><span class="p">){</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">color</span><span class="o">==</span><span class="n">RED</span><span class="p">){</span><span class="c1">//循环不变体中z的双亲结点是红色的，z也是红色</span>
<span class="w">        </span><span class="c1">//循环不变体中，如果有任何红黑性质被破坏，最多只有基本性质2或4中的一个被破坏</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="o">==</span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RED</span><span class="p">){</span>
<span class="w">                </span><span class="c1">//case1:z的叔结点y是红色的</span>
<span class="w">                </span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span><span class="w">  </span><span class="c1">//z的双亲变为黑色</span>
<span class="w">                </span><span class="n">y</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span><span class="w">    </span><span class="c1">//y变为黑色,即z的上一层变为黑色</span>
<span class="w">                </span><span class="c1">//将z移动到上上一层，即z的祖父结点，且保证下次处理z时z以下的子树以满足所有基本性质</span>
<span class="w">                </span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span><span class="w">  </span>
<span class="w">                </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">z</span><span class="o">==</span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">){</span>
<span class="w">                </span><span class="c1">//case2:z的叔结点y是黑色的且z是一个右孩子</span>
<span class="w">                </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">;</span><span class="w">    </span>
<span class="w">                </span><span class="n">Left_Rotate</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">//case3:z的叔结点y是黑色的且z是一个左孩子</span>
<span class="w">            </span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span>
<span class="w">            </span><span class="n">z</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span>
<span class="w">            </span><span class="n">Right_Rotate</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span>
<span class="w">            </span><span class="c1">//TODO:same as then claus with &quot;right&quot; and &quot;left&quot; exchange</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="删除">删除<a class="headerlink" href="#删除" title="Permanent link">&para;</a></h3>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">RB_Transplant</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="n">RBNode</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="n">RBNode</span><span class="w"> </span><span class="n">v</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//用于删除结点的子操作，用子树v代替子树u，即删除u结点，使用v代替</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">nil</span><span class="p">)</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w">    </span><span class="c1">//u结点是根结点</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w">    </span><span class="c1">//u是其双亲的左孩子，修正左孩子</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w">     </span><span class="c1">//u是其双亲的右孩子，修正右孩子</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">p</span><span class="p">;</span><span class="w">      </span><span class="c1">//修正双亲</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">RB_Delete</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="n">RBNode</span><span class="w"> </span><span class="n">z</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//参考二叉搜索树中删除结点时的三种情况</span>
<span class="w">    </span><span class="c1">//此处将第三种情况分为两种</span>
<span class="w">    </span><span class="c1">//case1|2:z的子结点少于两个.直接替换即可</span>
<span class="w">    </span><span class="c1">//case3:z的子结点等于两个，又分为3.1和3.2</span>
<span class="w">    </span><span class="c1">//case3.1:y为z的右儿子.用y替换z，仅留下y的右孩子(因为没有左孩子)</span>
<span class="w">    </span><span class="c1">//case3.2:y位于z的右子树中但不是z的右孩子.先用y的右孩子替换y，再用y替换z</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="n">y_original_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//如果z的子结点少于两个时，直接让子结点代替它</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">nil</span><span class="p">){</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">;</span><span class="w">    </span><span class="c1">//x为占有y原来位置的结点</span>
<span class="w">        </span><span class="n">RB_Transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">nil</span><span class="p">){</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">;</span><span class="w">    </span><span class="c1">//x为占有y原来位置的结点</span>
<span class="w">        </span><span class="n">RB_Transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">z</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//z的子结点等于两个</span>
<span class="w">    </span><span class="k">else</span><span class="p">{</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tree_MinMum</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">);</span><span class="w">   </span><span class="c1">//y为z的直接后继——z的右子树中最左边没有左子树的结点</span>
<span class="w">        </span><span class="n">y_original_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">;</span><span class="w">    </span><span class="c1">//x为z的右子树的根,z的后继y所在范围的树的根</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w">   </span><span class="c1">//y为z的右儿子,case4(3.1)</span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span><span class="c1">//case3.2,y位于z的右子树中但不是z的右孩子</span>
<span class="w">            </span><span class="n">RB_Transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="w">            </span><span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="w">            </span><span class="n">y</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">RB_Transplant</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
<span class="w">        </span><span class="n">y</span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">left</span><span class="p">;</span>
<span class="w">        </span><span class="n">y</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">        </span><span class="n">y</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//如果y是红色，当y被删除或移动时，红黑性质仍然保持，因为</span>
<span class="w">    </span><span class="c1">//1.树中的黑高没有变化</span>
<span class="w">    </span><span class="c1">//2.不存在两个相邻的红点。因为y在树中占据了被删除结点z的位置,再考虑到z的颜色，树中y的新位置不可能由两个相邻的红结点。</span>
<span class="w">    </span><span class="c1">//另外，如果y不是z的右孩子，则y的原右孩子x代替y。如果y是红，则x为黑，所以用x代替y不可能使两个红结点相邻</span>
<span class="w">    </span><span class="c1">//3.如果y是红色，就不可能是根结点，所以根结点仍旧是黑色</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">y_original_color</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLACK</span><span class="p">)</span><span class="w"> </span><span class="n">RB_Delete_FixUp</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">//如果y结点的初始颜色是黑色，需要进行修复</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>结点<code>y</code>是黑色的，会产生3个问题，均可通过下面的函数修正</p>
<ul>
<li>
<p><code>y</code>是原来的根结点，而<code>y</code>的一个红色的孩子成为新的根节点，违反了性质2</p>
</li>
<li>
<p>如果<code>x</code>和<code>x.p</code>是红色的，则违反了性质4</p>
</li>
<li>在树中移动<code>y</code>将导致先前包含<code>y</code>的任何简单路径上黑结点个数少<code>1</code>，<code>y</code>的任何祖先都不满足性质5。改正的办法是将现在占有<code>y</code>原来位置的结点<code>x</code>视为还有一重额外的黑色</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">RB_Delete_FixUp</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="n">RBNode</span><span class="w"> </span><span class="n">x</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//while循环的目标是将额外的黑色沿树上移，直到</span>
<span class="w">    </span><span class="c1">//1:x指向红黑结点，此时将x设为单个黑色</span>
<span class="w">    </span><span class="c1">//2:x指向根结点，此时可以简单地移除额外的黑色</span>
<span class="w">    </span><span class="c1">//3:执行适当的旋转和重新着色，退出循环</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">==</span><span class="n">BLACK</span><span class="p">){</span><span class="c1">//x始终指向一个具有双重黑色的非根结点</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">){</span><span class="c1">//x是其双亲的左孩子</span>
<span class="w">            </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">;</span><span class="c1">//w指向x的兄弟</span>
<span class="w">            </span><span class="c1">//下面4中情况的变化中，保持变化前后从子树的根到每棵子树的黑结点个数不变，</span>
<span class="w">            </span><span class="c1">//这样，如果性质5在变化之前成立，变化知火候也成立</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">color</span><span class="o">==</span><span class="n">RED</span><span class="p">){</span>
<span class="w">                </span><span class="c1">//case1:x的兄弟结点w是红色的</span>
<span class="w">                </span><span class="n">w</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span><span class="w">    </span><span class="c1">//转化为2,3,4情况进行处理</span>
<span class="w">                </span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span>
<span class="w">                </span><span class="n">Left_Rotate</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
<span class="w">                </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLACK</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">w</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLACK</span><span class="p">){</span>
<span class="w">                </span><span class="c1">//case2:x的兄弟结点w是黑色的，而且w的两个子结点都是黑色的</span>
<span class="w">                </span><span class="n">w</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span>
<span class="w">                </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BLACK</span><span class="p">){</span>
<span class="w">                </span><span class="c1">//case3:x的兄弟结点w是黑色的，w的左孩子红色，右孩子黑色</span>
<span class="w">                </span><span class="n">w</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span>
<span class="w">                </span><span class="n">w</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span>
<span class="w">                </span><span class="n">Right_Rotate</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
<span class="w">                </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">//case4:x的兄弟结点w是黑色的，w的右孩子红色</span>
<span class="w">            </span><span class="n">w</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
<span class="w">            </span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span>
<span class="w">            </span><span class="n">w</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span>
<span class="w">            </span><span class="n">Left_Rotate</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
<span class="w">            </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="c1">//TODO:same as then clause with &quot;right&quot; and &quot;left&quot; exchanged</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">x</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="顺序统计树">顺序统计树<a class="headerlink" href="#顺序统计树" title="Permanent link">&para;</a></h3>
<h4 id="定义_4">定义<a class="headerlink" href="#定义_4" title="Permanent link">&para;</a></h4>
<p>在红黑树的基础上，每个结点添加一个<code>size</code>的属性,表示以改该节点为根的子树的结点总数。</p>
<p><span class="arithmatex">\(x.size = x.left.size+x.right.size+1\)</span></p>
<h4 id="应用">应用<a class="headerlink" href="#应用" title="Permanent link">&para;</a></h4>
<ul>
<li>查找具有给定秩的元素</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">OS_Select</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">){</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">OS_Select</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">OS_Select</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>确定一个元素的秩</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">OS_Rank</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="p">){</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">y</span><span class="o">==</span><span class="n">T</span><span class="p">.</span><span class="n">root</span><span class="p">)){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="o">==</span><span class="n">y</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="o">+</span><span class="n">y</span><span class="p">.</span><span class="n">p</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="区间树">区间树<a class="headerlink" href="#区间树" title="Permanent link">&para;</a></h3>
<h4 id="定义_5">定义<a class="headerlink" href="#定义_5" title="Permanent link">&para;</a></h4>
<p>是一种对动态集合进行维护的红黑树，其中每个元素<code>x</code>都包含一个区间<code>x.int</code>。元素<code>x</code>的关键字为区间的左端点。每个结点<code>x</code>还包含一个附加信息为<code>x.max</code>，是以<code>x</code>为根的子树中所有区间的端点的最大值。</p>
<h2 id="斐波那契堆">斐波那契堆<a class="headerlink" href="#斐波那契堆" title="Permanent link">&para;</a></h2>
<p>斐波那契堆是一种可合并堆，其中的合并操作可在摊还时间<span class="arithmatex">\(O(1)\)</span>内完成</p>
<h3 id="可合并堆">可合并堆<a class="headerlink" href="#可合并堆" title="Permanent link">&para;</a></h3>
<p>可合并堆是支持以下操纵的一种数据结构
- <code>MAKE_HEAP()</code>：创建并返回一个新的不含任何元素的堆
- <code>INSERT(H,x</code>：讲一个已填入关键字的元素的x插入堆H中
- <code>MINMUM(H)</code>：返回一个指向堆H中具有最小关键字元素的指针
- <code>EXTRACT-MIN(H)</code>：从堆H中删除最小关键字的元素，并返回一个指向该元素的指针
- <code>UNION(H1,H2)</code>：创建并返回一个包含堆H1和堆H2中所有元素的堆。堆H1和堆H2由这一操作销毁</p>
<h3 id="斐波那契堆结构">斐波那契堆结构<a class="headerlink" href="#斐波那契堆结构" title="Permanent link">&para;</a></h3>
<ul>
<li>一个斐波那契堆是一系列具有最小堆序的有根树的集合。每棵树均遵循最小堆性质：每个节点的关键字大于或等于他的父节点的关键字。</li>
<li>所有树的根都用其left和right指针链成一个环形的双链表，称为<strong>根链表</strong></li>
<li>在一个含有n个节点的斐波那契堆中任何及诶单的最大度数都有上界<span class="arithmatex">\(D(n)\)</span>，且<span class="arithmatex">\(D(n)\)</span>的上界为<span class="arithmatex">\(O(\lg n)\)</span></li>
<li>根链表中的每个结点要求有一个与根链表中其他节点均不同的度数，这使得根链表的规模最大是<span class="arithmatex">\(D(n)+1\)</span>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">FIBNode</span><span class="p">{</span>
<span class="w">    </span><span class="n">FIBNode</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="c1">//指向其父节点</span>
<span class="w">    </span><span class="n">FIBNode</span><span class="o">*</span><span class="w"> </span><span class="n">child</span><span class="p">;</span><span class="c1">//指向其某个儿子节点</span>
<span class="w">    </span><span class="c1">//x的所有孩子被链接成一个环形的双向链表</span>
<span class="w">    </span><span class="n">FIBNode</span><span class="o">*</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="c1">//节点的左兄弟</span>
<span class="w">    </span><span class="n">FIBNode</span><span class="o">*</span><span class="w"> </span><span class="n">right</span><span class="p">;</span><span class="c1">//节点的右兄弟</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">degree</span><span class="p">;</span><span class="c1">//孩子链表中孩子的数目</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">mark</span><span class="p">;</span><span class="c1">//指示节点x自从上次成为另一个节点的孩子时，是否失去过孩子</span>
<span class="p">}</span><span class="n">FIBNode</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="n">FIB</span><span class="w"> </span><span class="n">H</span><span class="p">;</span><span class="c1">//H是一个斐波那契堆</span>
<span class="n">H</span><span class="p">.</span><span class="n">min</span><span class="p">;</span><span class="c1">//指向具有最小关键字的树的根节点</span>
<span class="n">H</span><span class="p">.</span><span class="n">n</span><span class="p">;</span><span class="c1">//H中当前节点数目</span>
</code></pre></div></td></tr></table></div></li>
</ul>
<h3 id="删除最小节点">删除最小节点<a class="headerlink" href="#删除最小节点" title="Permanent link">&para;</a></h3>
<ul>
<li>将最小节点的每个孩子节点变为根节点，并从根链表中删除该最小节点</li>
<li>通过把具有相同度数的根节点<strong>合并</strong>的方法来链接成根链表<ul>
<li>在根链表中找到两个具有相同度数的根<code>x</code>和根<code>y</code>。假设<span class="arithmatex">\(x.key \leq y.key\)</span></li>
<li>把<code>y</code>链接到<code>x</code>：从根链表中移除<code>y</code>，使<code>y</code>成为<code>x</code>的孩子。该过程清除<code>y</code>上的标记，<code>mark</code>设为<code>False</code></li>
<li>重复操作直到度数各部相同，期间使用一个辅助数组<span class="arithmatex">\(A[0…D(H.n)]\)</span>记录根节点对应度数的轨迹</li>
</ul>
</li>
</ul>
<h3 id="关键字减值">关键字减值<a class="headerlink" href="#关键字减值" title="Permanent link">&para;</a></h3>
<ul>
<li>如果关键字减值后仍然大大于其父节点，则无需操作</li>
<li>否则，则要进行切断<code>x</code>，即切断其父节点<code>y</code>与<code>x</code>的链接，使<code>x</code>成为根节点</li>
<li>mark用于记录节点<code>x</code>自从上次成为另一个节点的孩子时，是否失去过孩子。一旦失去第二个孩子，就切断<code>x</code>与其父节点的链接，使其成为新的节点。</li>
<li>注意切断<code>x</code>与<code>y</code>时，<code>y</code>也失去了孩子，可能是其第二个孩子，意味着切断可能会向上传递，直到遇到一个<code>mark</code>为<code>False</code>的节点</li>
</ul>
<h3 id="删除一个节点">删除一个节点<a class="headerlink" href="#删除一个节点" title="Permanent link">&para;</a></h3>
<ul>
<li>将该节点减值成为堆中最小的值</li>
<li>删除最小的值</li>
</ul>
<h2 id="van-emde-boas树理解不到位需日后修正">van Emde Boas树（理解不到位，需日后修正）<a class="headerlink" href="#van-emde-boas树理解不到位需日后修正" title="Permanent link">&para;</a></h2>
<h3 id="介绍">介绍<a class="headerlink" href="#介绍" title="Permanent link">&para;</a></h3>
<p>vEB树支持优先队列操作以及一些其他操作，每个操作最坏情况运行时间为<span class="arithmatex">\(O(\lg \lg n)\)</span>。而这种数据结构限制关键字必须为<span class="arithmatex">\(0 \sim u-1\)</span>的整数且无重复。<strong>全域</strong>集合为<span class="arithmatex">\(\{0,1,2,…,u-1\}\)</span>，假定u为2的幂<span class="arithmatex">\(u=2^k\)</span></p>
<h3 id="结构">结构<a class="headerlink" href="#结构" title="Permanent link">&para;</a></h3>
<p>将一个<span class="arithmatex">\(vEB(u)\)</span>分解为<span class="arithmatex">\(\sqrt{u}\)</span>个<span class="arithmatex">\(vEB(\sqrt u)\)</span>,使用这种递归的结构，使得操作的时间降为<span class="arithmatex">\(O(\lg \lg u)\)</span>。用一个数组<code>Summary</code>指向一颗<span class="arithmatex">\(vEB(\sqrt u)\)</span>树，该树中有一个数组，其中的每一个元素记录一颗树的情况。相当于一个节点记录了其子树的情况。这样，将树的高度压缩到了<span class="arithmatex">\(O(\lg \lg u)\)</span>。一共有<span class="arithmatex">\(\sqrt{u}\)</span>颗<span class="arithmatex">\(vEB(\sqrt u)\)</span>子树，每一颗子树为一<strong>簇</strong>，其父节点在summary所指树中的位置为其<strong>簇号</strong>
- 把一个数的<span class="arithmatex">\(\lg u\)</span>位分为高<span class="arithmatex">\(\lceil lg(u)/2 \rceil\)</span>和低<span class="arithmatex">\(\lfloor lg(u)/2 \rfloor\)</span>位。为方便起见，分别记为<span class="arithmatex">\(\sqrt[\uparrow]{u}\)</span>和<span class="arithmatex">\(\sqrt[\downarrow]{u}\)</span>，于是有<span class="arithmatex">\(u = \sqrt[\uparrow]{u}   \sqrt[\downarrow]{u}\)</span>
- <span class="arithmatex">\(high(x)=\lceil x/\sqrt[\downarrow]{u} \rceil\)</span>：用于确定x的簇号
- <span class="arithmatex">\(low(x)= x\mod \sqrt[\downarrow]{u}\)</span>：用于确定x在其簇中的位置
- <span class="arithmatex">\(index(x,y)=x\sqrt[\downarrow]{u}+y=index(high(x),low(x))\)</span>：定位x</p>
<h3 id="存储结构_1">存储结构<a class="headerlink" href="#存储结构_1" title="Permanent link">&para;</a></h3>
<ul>
<li><span class="arithmatex">\(u\)</span>： 将全域大小为<span class="arithmatex">\(u\)</span>的vEB树记为<span class="arithmatex">\(vEB(u)\)</span></li>
<li><span class="arithmatex">\(summary\)</span>：指向一棵<span class="arithmatex">\(vEB(\sqrt[\uparrow]{u})\)</span>树</li>
<li>数组<span class="arithmatex">\(cluster[0…\sqrt[\downarrow]{u}-1]\)</span>：指向<span class="arithmatex">\(\sqrt[\uparrow]{u} \ \ vEB(\sqrt[\downarrow]{u})\)</span>树</li>
<li><span class="arithmatex">\(min,max\)</span>：存储当前树的最大最小值。</li>
<li>存储在<span class="arithmatex">\(min\)</span>中的元素不出现在任何簇中，而存储在<span class="arithmatex">\(max\)</span>中的元素却不是这样的<ul>
<li>通过min，max值，可以在常数时间内告知一颗树是否为空，仅含一个元素还是两个以上元素</li>
<li>如果一颗树为空，可以仅更新他的minmax值来实现插入一个元素。</li>
</ul>
</li>
<li>当<span class="arithmatex">\(u=2\)</span>，没有<span class="arithmatex">\(summary\)</span>和<span class="arithmatex">\(Cluster\)</span>,只有<span class="arithmatex">\(min\)</span>，<span class="arithmatex">\(max\)</span>和<span class="arithmatex">\(u\)</span></li>
</ul>
<h2 id="散列表">散列表<a class="headerlink" href="#散列表" title="Permanent link">&para;</a></h2>
<h3 id="散列表的基本概念">散列表的基本概念<a class="headerlink" href="#散列表的基本概念" title="Permanent link">&para;</a></h3>
<ul>
<li>散列函数：一个把查找表中关键字映射成该关键字对应的地址的函数，记为<code>Hash(key)=Addr</code></li>
<li>冲突：散列函数把两个或两个以上的不同关键字映射到同一地址的现象</li>
<li>同义词：引起冲突的关键字</li>
<li>散列表：根据关键字而直接进行访问的数据结构。散列表建立了关键字和存储地址之间的一种直接映射关系</li>
</ul>
<h3 id="散列函数的构造方法">散列函数的构造方法<a class="headerlink" href="#散列函数的构造方法" title="Permanent link">&para;</a></h3>
<h4 id="散列函数的要求">散列函数的要求<a class="headerlink" href="#散列函数的要求" title="Permanent link">&para;</a></h4>
<ul>
<li>定义域包含全部关键字，值域依赖于散列表的大小或地址范围</li>
<li>散列函数计算出的地址应该能等概率、均匀的分布在整个地址空间中，减少冲突发生</li>
<li>尽可能简单，能够快速计算出散列地址</li>
</ul>
<table>
<thead>
<tr>
<th>常见构造函数</th>
<th>公式</th>
<th>评价</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接定地法</td>
<td><span class="arithmatex">\(H(key)=key\)</span>或<span class="arithmatex">\(H(key)=a \times key+b\)</span></td>
<td>最简单，不会产生冲突。适合关键字的分布基本连续的情况</td>
</tr>
<tr>
<td>除留余数法</td>
<td><span class="arithmatex">\(H(key)=key%p\)</span>，<span class="arithmatex">\(p\)</span>为不大于散列表表长<span class="arithmatex">\(m\)</span>但最接近或等于<span class="arithmatex">\(m\)</span>的质数</td>
<td></td>
</tr>
<tr>
<td>数字分析法</td>
<td>设关键字是r进制数，选取数码分布比较均匀的若干位作为散列地址</td>
<td>适合于一直的关键字集合，若更换了关键字，则需要重新构造新的散列函数</td>
</tr>
<tr>
<td>平方取中法</td>
<td>取关键字对的平方值的中间几位作为散列值</td>
<td>适用于关键字的每位取值都不均匀或均小于散列地址所需的位数</td>
</tr>
</tbody>
</table>
<h3 id="处理冲突的方法">处理冲突的方法<a class="headerlink" href="#处理冲突的方法" title="Permanent link">&para;</a></h3>
<ul>
<li>开放定址法，<span class="arithmatex">\(H_i=(H(key)+d_i)\%m\)</span>,<span class="arithmatex">\(m\)</span>表示散列表表长，<span class="arithmatex">\(d_i\)</span>为增量序列</li>
</ul>
<table>
<thead>
<tr>
<th>开放定址法</th>
<th><span class="arithmatex">\(d_i\)</span></th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性探测法</td>
<td><span class="arithmatex">\(0,1,2,...,m-1\)</span></td>
<td>可能出现大量元素在相邻地址上聚集，降低查找效率</td>
</tr>
<tr>
<td>平方探测法</td>
<td><span class="arithmatex">\(0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2\)</span></td>
<td>散列表长度m必须是一个可以表示成<code>4k+3</code>的素数</td>
</tr>
<tr>
<td>再散列法</td>
<td><span class="arithmatex">\(i*Hash_2(key)\)</span></td>
<td><span class="arithmatex">\(i\)</span>是冲突的次数</td>
</tr>
<tr>
<td>伪随机序列法</td>
<td><span class="arithmatex">\(d_i=\)</span>随机序列</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>拉链法</li>
</ul>
<p>把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识</p>
<h3 id="散列查找及性能分析">散列查找及性能分析<a class="headerlink" href="#散列查找及性能分析" title="Permanent link">&para;</a></h3>
<h4 id="查找过程">查找过程<a class="headerlink" href="#查找过程" title="Permanent link">&para;</a></h4>
<ol>
<li>初始化<code>Addr=Hash(key)</code></li>
<li>检测查找表中地址为<code>Addr</code>的位置上是否有记录，若无记录，返回查找失败；若有记录。比较它与key的值，若相等，则返回查找成功的标志，否则执行步骤3</li>
<li>用给定的处理冲突方法计算“下一个散列地址”，并将<code>Addr</code>置为此地址，转入步骤2</li>
</ol>
<p><strong>散列表的查找效率取决于散列函数、处理冲突的方法和装填因子</strong></p>
<ul>
<li>装填因子<span class="arithmatex">\(\alpha\)</span>定义为一个表的装满程度</li>
</ul>
<div class="arithmatex">\[
  \alpha = \frac{表中记录数n}{散列表长度m}
\]</div>
<h1 id="排序">排序<a class="headerlink" href="#排序" title="Permanent link">&para;</a></h1>
<h2 id="排序的基本概念">排序的基本概念<a class="headerlink" href="#排序的基本概念" title="Permanent link">&para;</a></h2>
<ul>
<li>排序：就是重新排列表中的元素，使表中的元素满足按关键字有序的过程</li>
<li>算法的稳定性：在排序之前关键字相同的元素，在排序后相对位置不变的排序算法是稳定的</li>
<li>内部排序：排序期间元素全部存放在内存中的排序</li>
<li>外部排序：排序期间元素无法全部同时同放在内存中，必须在排序的过程中根据要求不断的在内、外存之间移动的排序</li>
<li>可将排序算法分为：插入排序、交换排序、选择排序、归并排序和基数排序五大类</li>
</ul>
<h2 id="插入排序">插入排序<a class="headerlink" href="#插入排序" title="Permanent link">&para;</a></h2>
<p>基本思想：每次讲一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成</p>
<h3 id="直接插入排序">直接插入排序<a class="headerlink" href="#直接插入排序" title="Permanent link">&para;</a></h3>
<p>要将<code>L(i)</code>插入已有序的子序列<code>L[1...i-1]</code>，需要执行以下操作</p>
<ul>
<li>查找出<code>L(i)</code>在<code>L[1...i-1]</code>中的插入位置<code>k</code></li>
<li>
<p>将<code>L[k...i-1]</code>中的所有元素依次后移一个位置</p>
</li>
<li>
<p>将<code>L(i)</code>复制到<code>L(k)</code></p>
</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">InsertSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">   </span><span class="c1">//依次将A[2]...A[n]插入到前面已排序的序列</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]){</span><span class="w">    </span><span class="c1">//若A[i]小于前驱，则将其插入前面的有序表</span>
<span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">    </span><span class="c1">//哨兵</span>
<span class="w">            </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="o">--</span><span class="n">j</span><span class="p">)</span><span class="w">    </span><span class="c1">//从i-1开始比较，比较一次，向后移动一次</span>
<span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">  </span>
<span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">      </span><span class="c1">//找到插入位置，赋值</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="折半插入排序">折半插入排序<a class="headerlink" href="#折半插入排序" title="Permanent link">&para;</a></h3>
<ul>
<li>查找有序子表时用折半查找来实现</li>
<li>确定待插入位置后，同意以地向后移动元素</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">InsertSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">,</span><span class="n">mid</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">      </span><span class="c1">//依次将A[2]...A[n]插入到前面已排序的序列</span>
<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">        </span><span class="c1">//暂存单元，不是哨兵</span>
<span class="w">        </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">){</span><span class="w">       </span><span class="c1">//折半查找</span>
<span class="w">            </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]</span><span class="o">&gt;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="mi">-1</span><span class="p">;</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="mi">-1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="o">--</span><span class="n">j</span><span class="p">)</span><span class="w">    </span><span class="c1">//统一后移元素</span>
<span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">           </span><span class="c1">//赋值</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div></td></tr></table></div>
<h3 id="希尔排序">希尔排序<a class="headerlink" href="#希尔排序" title="Permanent link">&para;</a></h3>
<p>基本思想：先将待排序表分割成若干形如<code>L[i,i+d,i+2d,...,i+kd]</code>的特殊子表，即把相隔某个“增量”的记录组成一个子表，对每个子表分别进行直接插入排序，当整个表中的元素已呈“毕本有序”时，再对全体记录进行一次直接插入排序</p>
<p><strong>过程</strong></p>
<ul>
<li>先取一个小于n的步长<span class="arithmatex">\(d_1\)</span>,把表中的全部记录分成<span class="arithmatex">\(d_1\)</span>组，所有距离为<span class="arithmatex">\(d_1\)</span>的倍数的记录放在同一组，在各组内进行直接插入排序</li>
<li>然后取第二个步长<span class="arithmatex">\(d_2&lt;d_1\)</span>.</li>
<li>重复上述过程，直到所取到的<span class="arithmatex">\(d_t=1\)</span>，即所有记录已放在同一组，再进行直接插入排序</li>
</ul>
<p><strong>增量序列：</strong><span class="arithmatex">\(d_1=n/2,d_{i+1}=\lfloor d_i/2 \rfloor\)</span>,最后一个增量等于1</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ShellSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//A[0]只是暂存单元，不是哨兵</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">dk</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">dk</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span><span class="n">dk</span><span class="o">=</span><span class="n">dk</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="w">       </span><span class="c1">//步长变换</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">dk</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w">        </span><span class="c1">//对d_i个组进行直接插入排序</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">dk</span><span class="p">]){</span><span class="w">       </span><span class="c1">//需要将A[i]插入所在的有序子表中</span>
<span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">        </span><span class="c1">//暂存A[i]</span>
<span class="w">                </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">dk</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="n">j</span><span class="o">-=</span><span class="n">dk</span><span class="p">)</span><span class="c1">//寻找插入位置</span>
<span class="w">                    </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">dk</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w">     </span><span class="c1">//记录后移</span>
<span class="w">                </span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">dk</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">         </span><span class="c1">//插入</span>
<span class="w">            </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h2 id="交换排序">交换排序<a class="headerlink" href="#交换排序" title="Permanent link">&para;</a></h2>
<h3 id="冒泡排序">冒泡排序<a class="headerlink" href="#冒泡排序" title="Permanent link">&para;</a></h3>
<p>基本思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序则交换，指导序列比较完。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">BubbleSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">               </span><span class="c1">//表示本趟冒泡是否发生交换的标志</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="w">          </span><span class="c1">//一趟冒泡过程</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span><span class="w">        </span><span class="c1">//若为逆序</span>
<span class="w">                </span><span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span><span class="w">  </span><span class="c1">//交换</span>
<span class="w">                </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="o">==</span><span class="nb">false</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span><span class="w">         </span><span class="c1">//本趟遍历后没有发生交换，说明表已经有序</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>注意：冒泡排序所产生的有序子序列是全局有序的。每一趟排序都会将一个元素放置到其最终的位置上</p>
<h3 id="快速排序">快速排序<a class="headerlink" href="#快速排序" title="Permanent link">&para;</a></h3>
<p>基本思想：在待排序表<code>L[1...n]</code>中任取一个元素<code>pivot</code>作为<strong>枢轴</strong>,通过一趟排序将待排序表划分为独立的两个部分<code>L[1...k-1]</code>和<code>L[k+1...n]</code>,使得<code>L[1...k-1]</code>中的所有元素小于<code>pivot</code>,<code>L[k+1...n]</code>中的所有元素大于等于<code>pivot</code>,则<code>pivot</code>放在了其最终位置<code>L(k)</code>上，这个过程称为一趟快速排序。然后分别对左右两部分重复上述过程，直到每个部分只有一个元素。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">QuickSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span>
<span class="w">        </span><span class="c1">//Partition()就是划分操作，将表划分成满足条件的两个子表</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pivotpos</span><span class="o">=</span><span class="n">Partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w"> </span><span class="c1">//划分</span>
<span class="w">        </span><span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">pivotpos</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">        </span><span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pivots</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">Partition</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span><span class="w">   </span><span class="c1">//一趟划分</span>
<span class="w">    </span><span class="n">ElemType</span><span class="w"> </span><span class="n">pivot</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="n">high</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">];</span><span class="w">       </span><span class="c1">//将比枢轴小的元素移动到左边</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">pivot</span><span class="p">)</span><span class="w"> </span><span class="n">low</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span><span class="w">       </span><span class="c1">//将比枢轴大的元素移动到右边</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span><span class="w">         </span><span class="c1">//枢轴放到最终位置</span>
<span class="w">    </span><span class="n">reutrn</span><span class="w"> </span><span class="n">low</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>快速排序是所有内部排序算法中平均性能最优的排序算法</p>
<h2 id="选择排序">选择排序<a class="headerlink" href="#选择排序" title="Permanent link">&para;</a></h2>
<h3 id="简单选择排序">简单选择排序<a class="headerlink" href="#简单选择排序" title="Permanent link">&para;</a></h3>
<p>基本思想：假设排序表为<code>L[1...n]</code>,第<code>i</code>趟排序即从<code>L[i...n]</code>中选择关键字最小的元素与<code>L(i)</code>交换，每一趟排序可以确定一个元素的最终位置，经过n-1趟排序可以使整个排序表有序</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">SelectSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">             </span><span class="c1">//一共进行n-1趟</span>
<span class="w">        </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">                    </span><span class="c1">//记录最小元素位置</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">          </span><span class="c1">//在A[1...n-1]中选择最小的元素</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">])</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w">    </span><span class="c1">//更新最小的元素</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">min</span><span class="o">!=</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">]);</span><span class="w">   </span><span class="c1">//封装的swap()函数共移动3次</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="堆排序">堆排序<a class="headerlink" href="#堆排序" title="Permanent link">&para;</a></h3>
<ul>
<li>大根堆：<code>L(i)&gt;=L(2i) &amp; L(i)&gt;=L(2i+1)</code>,最大元素在根结点</li>
<li>小根堆：<code>L(i)&lt;=L(2i) &amp; L(i)&lt;=L(2i+1)</code>,最小元素在根结点</li>
<li>
<p>堆的插入：把新结点放到堆的末端，后进行向上调整</p>
</li>
<li>
<p>构造初始堆：</p>
</li>
<li><span class="arithmatex">\(n\)</span>个结点的完全二叉树，最后一个结点是第<span class="arithmatex">\(\lfloor n/2 \rfloor\)</span>个结点的孩子。对第<span class="arithmatex">\(\lfloor n/2 \rfloor\)</span>个结点为根的子树筛选（对于的大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。</li>
<li>之后向前依次对各节点<span class="arithmatex">\(\lfloor n/2 \rfloor-1 \sim 1\)</span>为根的子树进行筛选，看该结点值是否大于其左右子节点的值，不大于的话进行交换</li>
<li>交换后可能会破坏下一级的堆，使用上述办法继续构造下一级的堆，直到以根结点形成堆为止</li>
<li>输出堆顶元素，重新构建堆，重复这一过程</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">BuildMaxHead</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//自底向上建堆</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w">    </span><span class="c1">//从i=n/2开始，反复调整堆</span>
<span class="w">        </span><span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">len</span><span class="p">);</span><span class="w">    </span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">HeadAdjust</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//将元素k为根的子树进行调整</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w">    </span><span class="c1">//A[0]暂存子树的根节点</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">){</span><span class="w">      </span><span class="c1">//沿key较大的子节点向下筛选</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w">  </span><span class="c1">//取i为较大子结点</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="k">break</span><span class="p">;</span><span class="w">    </span><span class="c1">//筛选结束</span>
<span class="w">        </span><span class="k">else</span><span class="p">{</span>
<span class="w">            </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">          </span><span class="c1">//将A[i]调整到双亲结点上</span>
<span class="w">            </span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w">        </span><span class="c1">//修改k值，继续向下筛选</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">        </span><span class="c1">//被筛选结点的值放入最终位置</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">HeapSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//A[1]存放根结点</span>
<span class="w">    </span><span class="n">BuildMAxHeap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span><span class="w">     </span><span class="c1">//n-1趟的交换和建堆过程</span>
<span class="w">        </span><span class="n">Swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">    </span><span class="c1">//输出堆顶元素，和堆底元素交换</span>
<span class="w">        </span><span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="mi">-1</span><span class="p">);</span><span class="c1">//调整，把剩余的i-1个元素整理成堆</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h4 id="应用--优先队列">应用--优先队列<a class="headerlink" href="#应用--优先队列" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>优先队列是一种用来维护由一组元素构成的集合<code>S</code>的数据结构，其中的每个元素都有一个相关的值，称为<strong>关键字</strong>。</p>
</li>
<li>
<p>有<strong>最大优先队列</strong>和<strong>最小优先队列</strong>。最大优先队列的应用：在共享计算机系统的作业调度，用于记录将要执行的各个作业以及他们的优先级；最小优先队列的应用：用于基于事件驱动的模拟器。</p>
</li>
<li>在用堆来实现优先队列时，需要在堆中的每个元素里存储对应对象的<strong>句柄</strong><code>handle</code>。句柄的准确含义依赖于具体的应用程序。</li>
<li>操作</li>
<li><code>Insert(S,x)</code>：把元素<code>x</code>插入集合S中</li>
<li><code>Maxmum(S)</code>：返回<code>S</code>中具有最大键字的元素</li>
<li><code>Extract-max(S)</code>：去掉并返回<code>S</code>中具有最大键字的元素</li>
<li><code>Increase-key(S,x,k)</code>：将元素<code>x</code>的关键字增加到<code>k</code>，这里假设<code>k</code>的值不小于<code>x</code>的原关键字            </li>
</ul>
<h2 id="归并排序和基数排序">归并排序和基数排序<a class="headerlink" href="#归并排序和基数排序" title="Permanent link">&para;</a></h2>
<h3 id="归并排序">归并排序<a class="headerlink" href="#归并排序" title="Permanent link">&para;</a></h3>
<p>假定待排序表含有n个记录，则可将其视为n个有序的子表，每个子表的长度为1，然后两两合并，得到<span class="arithmatex">\(\lceil n/2 \rceil\)</span>个长度为2或1的有序表，继续两两合并。这种排序方法称为2路归并排序。</p>
<p>一趟归并排序的操作是，调用<span class="arithmatex">\(\lceil n/2h \rceil\)</span>次算法<code>merge()</code>,将<code>L[1...n]</code>中前后相邻且长度为h的有序段进行两两归并，得到前后相邻、长度为2h的有序段进行两两归并，得到前后相邻、长度为<span class="arithmatex">\(2h\)</span>的有序段，整个归并排序需要进行<span class="arithmatex">\(\lceil log_2n\rceil\)</span>趟</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">ELemType</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ElemType</span><span class="p">));</span><span class="w"> </span><span class="c1">//辅助数组B</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Merge</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="w">  </span><span class="c1">//将A中元素放到B中</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="w">    </span><span class="c1">//将较小值赋值到A中</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span><span class="w">  </span><span class="c1">//若一个表未检测完，赋值</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">)</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span><span class="w"> </span><span class="c1">//若第二个表未检测完，赋值</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MergeSort</span><span class="p">(</span><span class="n">ElemType</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">){</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
<span class="w">        </span><span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
<span class="w">        </span><span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="w">  </span><span class="c1">//归并</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="计数排序">计数排序<a class="headerlink" href="#计数排序" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>假设<span class="arithmatex">\(n\)</span>个输入元素中的每一个都是在<span class="arithmatex">\(0\)</span>到<span class="arithmatex">\(k\)</span>区间内的一个整数，其中<span class="arithmatex">\(k\)</span>为某个整数。当<span class="arithmatex">\(k=O(n)\)</span>时，排序的运行时间为<span class="arithmatex">\(O(n)\)</span>。</p>
</li>
<li>
<p>基本思想：对每一个输入元素<span class="arithmatex">\(x\)</span>，确定小于<span class="arithmatex">\(x\)</span>的元素个数。利用这一信息，就可以直接把<span class="arithmatex">\(x\)</span>放到它在输出数组中的位置上了。</p>
</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">CountingSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">B</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//A为输入数组，B存放结果，k表示输入数组中数字在0-k</span>
<span class="w">    </span><span class="kt">int</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="n">C</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="c1">//初始化</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span><span class="c1">//累加,此时C[i]表示不超过i的数字有多少</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
<span class="w">        </span><span class="n">B</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//C[A[i]]为A[i]应该存放的位置</span>
<span class="w">        </span><span class="n">C</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="基数排序">基数排序<a class="headerlink" href="#基数排序" title="Permanent link">&para;</a></h3>
<ul>
<li>最高位优先法<code>MSD</code>:将关键字位权重递减一次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列</li>
<li>最低位优先法<code>LSD</code>：将关键字权重递增一次进行排序，最后形成一个有序序列</li>
</ul>
<p>排序过程：</p>
<ul>
<li>
<p>在排序中，使用r个队列<span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span></p>
</li>
<li>
<p>对<span class="arithmatex">\(i=0,1,...,d-1\)</span>，依次做一次<strong>分配</strong>和<strong>收集</strong>，每个关键字结点<span class="arithmatex">\(a_j\)</span>由<span class="arithmatex">\(d\)</span>元组组成</p>
</li>
<li>分配：开始时，把<span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span>各个队列置成空队列，然后依次考察线性表中的每个结点<span class="arithmatex">\(a_j\)</span>,若<span class="arithmatex">\(a_j\)</span>的关键字<span class="arithmatex">\(k_j^i=k\)</span>，就把<span class="arithmatex">\(a_j\)</span>放进<span class="arithmatex">\(Q_k\)</span>队列中</li>
<li>收集：把<span class="arithmatex">\(Q_0,Q_1,...,Q_{r-1}\)</span>各个队列中的结点依次首尾相连，得到新的结点序列，从而组成新的线性表</li>
</ul>
<h3 id="桶排序">桶排序<a class="headerlink" href="#桶排序" title="Permanent link">&para;</a></h3>
<ul>
<li>桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为<span class="arithmatex">\(O(n)\)</span>。与计数排序类似，因为对输入数据做了某种假设，桶排序的速度也很快。具体来说，计数排序假设输入数据都属于一个小区间内的整数，而桶排序则假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在<span class="arithmatex">\([0,1)\)</span>区间上。</li>
<li>桶排序将<span class="arithmatex">\([0,1)\)</span>区间划分为<span class="arithmatex">\(n\)</span>个相同大小的子区间，或称为<strong>桶</strong>。然后，将n个输入数分别放到各个桶中。因为输入数据是均匀、独立地分布在<span class="arithmatex">\([0,1)\)</span>区间上，所以一般不会出现很多数落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。</li>
</ul>
<h2 id="各种内部排序算法比较及应用">各种内部排序算法比较及应用<a class="headerlink" href="#各种内部排序算法比较及应用" title="Permanent link">&para;</a></h2>
<h3 id="内部排序算法的比较">内部排序算法的比较<a class="headerlink" href="#内部排序算法的比较" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>算法种类</th>
<th>时间复杂度-最好</th>
<th>时间复杂度-平均</th>
<th>时间复杂度-最坏</th>
<th>空间复杂度</th>
<th>是否稳定</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>冒泡排序</td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>简单选择排序</td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>希尔排序</td>
<td></td>
<td></td>
<td></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>快速排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n^2)\)</span></td>
<td><span class="arithmatex">\(O(\log_2n)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>堆排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(1)\)</span></td>
<td>否</td>
</tr>
<tr>
<td>2路归并排序</td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n\log_2n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>计数排序</td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>基数排序</td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(d(n+r))\)</span></td>
<td><span class="arithmatex">\(O(r)\)</span></td>
<td>是</td>
</tr>
<tr>
<td>桶排序</td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td><span class="arithmatex">\(O(n)\)</span></td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="应用_1">应用<a class="headerlink" href="#应用_1" title="Permanent link">&para;</a></h3>
<h4 id="选取排序方法需要考虑的因素">选取排序方法需要考虑的因素<a class="headerlink" href="#选取排序方法需要考虑的因素" title="Permanent link">&para;</a></h4>
<ul>
<li>待排序的元素数目<span class="arithmatex">\(n\)</span>：较小考虑直接插入和简单选择排序，较大考虑快排、堆排序、归并排序</li>
<li>元素本身信息量的大小：是否选取移动量较少的排序方法</li>
<li>关键字的结构及其分布情况：如已经有序，则选取直接插入或冒泡排序</li>
<li>稳定性的要求</li>
<li>语言工具的要求，存储结构及辅助空间的大小等</li>
</ul>
<h2 id="外部排序">外部排序<a class="headerlink" href="#外部排序" title="Permanent link">&para;</a></h2>
<ul>
<li>外部排序指待排序文件较大，内存一次放不下，需存放在外存的文件的排序</li>
<li>为减少平衡归并中外存读写次数所采取的方法：增大归并路数和减少归并段个数</li>
<li>利用败者树增大归并路数</li>
<li>利用置换-选择排序增大归并段长度来减少归并段的个数</li>
</ul>
<h3 id="外部排序的基本概念">外部排序的基本概念<a class="headerlink" href="#外部排序的基本概念" title="Permanent link">&para;</a></h3>
<p>在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存之上，排序时再把数据一部分一部分地调进内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为<strong>外部排序</strong></p>
<h3 id="外部排序的方法">外部排序的方法<a class="headerlink" href="#外部排序的方法" title="Permanent link">&para;</a></h3>
<ul>
<li>根据内存缓冲区的大小，将外存上的文件分成若干长度为<span class="arithmatex">\(l\)</span>的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存，称这些有序子文件称为归并段或顺串</li>
<li>对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为止</li>
<li><code>外部排序的总时间=内部排序所需时间+外存信息读写的时间+内部归并所需的时间</code></li>
<li>在进行归并的时候，需要使用输入缓冲区和输出缓冲区，在内存和外存中传输数据</li>
<li>对<code>r</code>个初始段归并，做<code>k</code>路平衡归并，归并树可用严格k叉树来表示，树的高度=<span class="arithmatex">\(\lceil \log_kr\rceil\)</span>=归并趟数S</li>
</ul>
<h3 id="多路平衡归并与败者树">多路平衡归并与败者树<a class="headerlink" href="#多路平衡归并与败者树" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>做内部归并时，在k个元素中选择关键字最小的记录需要比较k-1次，S趟归并总需的比较次数是<span class="arithmatex">\(S(n-1)(k-1)=\lceil \log_kr\rceil(n-1)(k-1)=\lceil \log_2r \rceil (n-1)(k-1)\lceil \log_2k \rceil\)</span></p>
</li>
<li>
<p>引入败者树后，在k个元素中选择关键字最小的记录需要比较<span class="arithmatex">\(\lceil \log_2k \rceil\)</span>次，内部归并的比较次数与k无关。因此只要内存允许，增大归并路数k将有效减少归并树的高度，提高外部排序饿的速度</p>
</li>
<li>
<p>败者树</p>
</li>
<li>k个叶结点分别存放k个归并段在归并过程中当前参加比较的记录</li>
<li>内存结点用来记忆左右子树中的失败者，而让胜者往上继续比较，一直到根结点</li>
<li>根结点记录胜者</li>
<li>叶结点进行编号<span class="arithmatex">\(b0 \sim bk\)</span>,内存结点编号<span class="arithmatex">\(ls[0] \sim ls[k]\)</span>,<span class="arithmatex">\(ls[0]\)</span>为根结点</li>
</ul>
<h3 id="置换-选择排序生成初始归并段">置换-选择排序（生成初始归并段）<a class="headerlink" href="#置换-选择排序生成初始归并段" title="Permanent link">&para;</a></h3>
<p>初始待排文件<code>FI</code>,初始归并段输出文件为<code>FO</code>,内存工作区为<code>WA</code>,<code>FO</code>与<code>WA</code>的初始状态为空，<code>WA</code>可容纳<span class="arithmatex">\(w\)</span>个记录</p>
<ol>
<li>从<code>FI</code>输入w个记录到工作区<code>WA</code></li>
<li>从<code>WA</code>中选出其中关键字取最小值的记录，记为<code>MINIMAX</code></li>
<li>将<code>MINIMAX</code>就输出到<code>FO</code>中去</li>
<li>若<code>FI</code>不为空，则从FI输入下一个记录到<code>WA</code>中</li>
<li>从<code>WA</code>中鄋关键字比<code>MINIMAX</code>记录的关键字大的记录中选出最小关键字记录，作为新的<code>MINIMAX</code></li>
<li>重复<code>3-5</code>，直至在<code>WA</code>中选不出新的<code>MINIMAX</code>记录为止，由此得到一个初始归并段，输出一个归并段的结束标志至<code>FO</code>中去</li>
<li>重复<code>2-6</code>，直至<code>WA</code>为空，由此得到全部初始归并段</li>
</ol>
<h3 id="最佳归并树">最佳归并树<a class="headerlink" href="#最佳归并树" title="Permanent link">&para;</a></h3>
<p>把归并段的长度作为权值，进行严格k叉树的哈夫曼树思想，构造最佳归并树</p>
<ul>
<li><span class="arithmatex">\((n_0-1)\%(k-1)=0\)</span>,不需要添加</li>
<li><span class="arithmatex">\((n_0-1)\%(k-1)=u\neq0\)</span>,需要添加<span class="arithmatex">\(k-1-u\)</span>个长度为0的虚段</li>
</ul>
<h1 id="计算几何学">计算几何学<a class="headerlink" href="#计算几何学" title="Permanent link">&para;</a></h1>
<h2 id="线段的性质">线段的性质<a class="headerlink" href="#线段的性质" title="Permanent link">&para;</a></h2>
<ul>
<li>线段的端点：<span class="arithmatex">\(p_1 = (x_1,y_1)\)</span></li>
<li>线段的表示：<span class="arithmatex">\(\overline{p_1p_2}\)</span></li>
</ul>
<h3 id="叉积">叉积<a class="headerlink" href="#叉积" title="Permanent link">&para;</a></h3>
<p>向量<span class="arithmatex">\(p_1,p_2\)</span>（相当于前面的<span class="arithmatex">\(p_1p_o,p_2p_o\)</span>,一个公共顶点是原点）</p>
<div class="arithmatex">\[
p_1 \times p_2 = 
\begin{vmatrix}
x_1 &amp;x_2\\
y_1 &amp;y_2
\end{vmatrix}
=x_1y_2-x_2y_1 = - p_2 \times p_1
\]</div>
<p>若<span class="arithmatex">\(p_1 \times p_2\)</span>为正，则相对于原点<span class="arithmatex">\((0,0)\)</span>来说，<span class="arithmatex">\(p_1\)</span>位于<span class="arithmatex">\(p_2\)</span>的顺时针方向，否则为逆时针方向</p>
<h3 id="判断有共同顶点的两条线段的相对位置">判断有共同顶点的两条线段的相对位置<a class="headerlink" href="#判断有共同顶点的两条线段的相对位置" title="Permanent link">&para;</a></h3>
<p>为了确定相对于公共断点<span class="arithmatex">\(p_0\)</span>,有向线段<span class="arithmatex">\(\overrightarrow{p_0p_1}\)</span>是在<span class="arithmatex">\(\overrightarrow{p_0p_2}\)</span>的顺时针方向还是逆时针方向，用<span class="arithmatex">\(p_1-p_0\)</span>来表示<span class="arithmatex">\(p_1'=(x_1',y_1')=(x_1-x_0,y_1-y_0)\)</span>,类似的定义<span class="arithmatex">\(p_2-p_0\)</span>,计算叉积
<span class="arithmatex">\((p_1-p_0)\times (p_2-p_0) = (x_1-x_0)(y_2-y_0)-(x_2-x_0)(y_1-y_0)\)</span>
如果叉积为正，那么<span class="arithmatex">\(\overrightarrow{p_0p_1}\)</span>位于<span class="arithmatex">\(\overrightarrow{p_0p_2}\)</span>的顺时针方向，否则为逆时针方向。</p>
<h3 id="确定连续线段是向左转还是向右转">确定连续线段是向左转还是向右转<a class="headerlink" href="#确定连续线段是向左转还是向右转" title="Permanent link">&para;</a></h3>
<p>判断两条连续的线段<span class="arithmatex">\(\overline{p_0p_1}\)</span>和<span class="arithmatex">\(\overline{p_1p_2}\)</span>是向左转还是向右转，即计算<span class="arithmatex">\(\angle{p_0p_1p_2}\)</span>的转向
计算叉积<span class="arithmatex">\((p_2-p_0)\times(p_1-p_0)\)</span>。如果结果为负，则<span class="arithmatex">\(\overrightarrow{p_0p_2}\)</span>在<span class="arithmatex">\(\overrightarrow{p_0p_1}\)</span>的逆时针方向，在<span class="arithmatex">\(p_1\)</span>处左转；结果为正，恰好相反。</p>
<h3 id="判定两条线段是否相交">判定两条线段是否相交<a class="headerlink" href="#判定两条线段是否相交" title="Permanent link">&para;</a></h3>
<p>为判定两条线段是否相交，需要检查每条线段是否跨越了了包含另一条线段的直线。如果点<span class="arithmatex">\(p_1\)</span>位于某条直线的一边，而点<span class="arithmatex">\(p_2\)</span>位于该直线的另一边，则称线段<span class="arithmatex">\(\overline{p_1p_2}\)</span>跨越了这条直线。若<span class="arithmatex">\(p_1\)</span>和<span class="arithmatex">\(p_2\)</span>恰好落在直线上，则出现边界情况。两条线段相交当且仅当下面两个条件至少成立一个：
- 每条线段都跨越了包含另一条线段的直线
- 一条线段的某个端点落在另一条直线上
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">SegmentsIntersect</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">):</span>
    <span class="c1">#如果线段p1p1和p3p4相交，返回true；否则返回false</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">Direction</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">,</span><span class="n">p1</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">Direction</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
    <span class="n">d3</span> <span class="o">=</span> <span class="n">Direction</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">)</span>
    <span class="n">d4</span> <span class="o">=</span> <span class="n">Direction</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d1</span><span class="o">*</span><span class="n">d2</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">d3</span><span class="o">*</span><span class="n">d4</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">d1</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">OnSegment</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">,</span><span class="n">p1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">d2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">OnSegment</span><span class="p">(</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">d3</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">OnSegment</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">d4</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">OnSegment</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p4</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">true</span>        
    <span class="k">else</span> <span class="k">return</span> <span class="n">true</span>
<span class="n">Direction</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="n">pj</span><span class="p">,</span><span class="n">pk</span><span class="p">):</span>
    <span class="c1">#计算线段的相对方向</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pk</span><span class="o">-</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pj</span><span class="o">-</span><span class="n">pi</span><span class="p">)</span>
<span class="n">OnSegment</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="n">pj</span><span class="p">,</span><span class="n">pk</span><span class="p">):</span>
    <span class="c1">#判断一个与线段共线的点是否位于这条线段上</span>
    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">xj</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">xk</span><span class="o">&lt;=</span><span class="nb">max</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">xj</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span><span class="n">yj</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">yk</span><span class="o">&lt;=</span><span class="nb">max</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span><span class="n">yj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">false</span>
</code></pre></div></td></tr></table></div></p>
<h2 id="确定任意一对线段是否相交">确定任意一对线段是否相交<a class="headerlink" href="#确定任意一对线段是否相交" title="Permanent link">&para;</a></h2>
<p>使用一种称为"扫除"的技巧，在扫除过程中，一条假想的扫除线<code>sweep line</code>穿过一个给定的几何物体集合，并且通常是从左到右扫描。考虑扫除线移动的空间维度，当沿x维移动时，则将其看做时间维，扫除提供了一种将几何物体排序的方法，通常将其放入一个动态数据结构，从而充分利用其相互关系。
为了简化问题，作出以下假设(实际上可以简单的修改程序得以实现)
 -没有一条输入线段是垂直的
 没有三条输入线段相交于同一点</p>
<h3 id="线段排序">线段排序<a class="headerlink" href="#线段排序" title="Permanent link">&para;</a></h3>
<p>使用的扫除线是一条垂直扫除线,因为任何与给定的垂直扫除线相交的线段与其只有一个交点。所以我们可以根据交点的y坐标来对与垂直扫除线相交的线段排序
- 考虑两条线段<span class="arithmatex">\(s_1\)</span>和<span class="arithmatex">\(s_2\)</span>，如果一条x坐标值为x的扫除线与二者都相交，则将这两条线段在扫除线在x处是可比较的。
- 如果<span class="arithmatex">\(s_1\)</span>和<span class="arithmatex">\(s_2\)</span>在x处是可比较的，并且在x处，<span class="arithmatex">\(s_1\)</span>与扫除线的交点比<span class="arithmatex">\(s_2\)</span>与同一条扫除线的交点要高，或者两者在扫除线上相交，则称在x处<span class="arithmatex">\(s_1\)</span>位于<span class="arithmatex">\(s_2\)</span>之上，记作<span class="arithmatex">\(s_1 \geq_x s_2\)</span>
- 当线段的左端点遇到扫除线时，就进入该排序；当其右端点遇到扫除线时，就离开该排序</p>
<h3 id="移动扫除线">移动扫除线<a class="headerlink" href="#移动扫除线" title="Permanent link">&para;</a></h3>
<p>扫除算法要维护两组数据
- 扫除线状态<code>sweep-line status</code>给出了与扫除线相交的物体之间的关系
- 事件点调度<code>event point schedule</code>是一个按x坐标从左到右排列的事件点序列。随着扫除线由左到右进行，每当遇到事件点的x坐标，扫除都会暂停，处理事件点，然后重新开始扫除扫除线状态仅在事件点处改变
特别的，每个线段端点都是事件点，我们通过增加x坐标值，并且从左向右执行，来对线段端点进行排序。当遇到线段的左端点时，就将此线段插入扫除线状态中，并且当遇到其右端点时就把它从扫除线状态中删掉。每当两条线段首次在完全前序中变为连续时，就检查它们是否相交。
扫除线状态是一个完全前序关系<code>T</code>，需要对其进行以下操作
- <code>Insert(T,s)</code>：把线段<code>s</code>插入<code>T</code>中
- <code>Delete(T,s)</code>：把线段<code>s</code>从<code>T</code>中删除掉
- <code>Above(T,s)</code>：返回<code>T</code>中<code>s</code>上方紧挨着<code>s</code>的线段
- <code>Below(T,s)</code>：返回<code>T</code>中<code>s</code>下方紧挨着<code>s</code>的线段</p>
<h3 id="求线段交点的伪代码">求线段交点的伪代码<a class="headerlink" href="#求线段交点的伪代码" title="Permanent link">&para;</a></h3>
<p>使用红黑树作为动态数据结构存储事件点，算法时间复杂度为<span class="arithmatex">\(O(n\log n)\)</span>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">AnySegmentsIntersect</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="c1">#如果S中有任何一对线段相交，则返回true</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">null</span>
    <span class="c1"># TODO</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    sort the endpoints of the segments in s from left to right;</span>
<span class="sd">    breaking ties by putting left endpoints before right endpoints</span>
<span class="sd">    and breaking further ties by putting points with lower </span>
<span class="sd">    y-coordinates first</span>
<span class="sd">    相当于对端点(x,e,y)进行字典排序，x,y为对应坐标，e=0为左端点，e=1为右端点</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">each</span> <span class="n">point</span> <span class="n">p</span> <span class="nb">int</span> <span class="n">the</span> <span class="nb">sorted</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">endpoints</span><span class="p">:</span>
        <span class="c1">#处理事件点p</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">left</span> <span class="n">endpoints</span> <span class="n">of</span> <span class="n">a</span> <span class="n">segment</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">Insert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Aobve</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">exists</span> <span class="ow">and</span> <span class="n">intersects</span> <span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">Below</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">exists</span> <span class="ow">and</span> <span class="n">intersects</span> <span class="n">s</span><span class="p">):</span>
            <span class="c1">#如果上面的或下面的线段与s在p处与其相交</span>
                <span class="k">return</span> <span class="n">true</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">right</span> <span class="n">endpoint</span> <span class="n">of</span> <span class="n">a</span> <span class="n">segment</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">both</span> <span class="n">Above</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Below</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">exist</span> 
                <span class="ow">and</span> <span class="n">Above</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="n">intersects</span> <span class="n">Below</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
            <span class="c1">#如果s线段的上下两条线段相交，使用前面讲到的叉积方法</span>
                <span class="k">return</span> <span class="n">true</span>
            <span class="n">delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">false</span>
</code></pre></div></td></tr></table></div></p>
<h2 id="寻找凸包">寻找凸包<a class="headerlink" href="#寻找凸包" title="Permanent link">&para;</a></h2>
<p>点集<span class="arithmatex">\(Q\)</span>的凸包是一个最小的凸多边形<span class="arithmatex">\(P\)</span>，满足<span class="arithmatex">\(Q\)</span>中的每个点都在<span class="arithmatex">\(P\)</span>的边界上或者在<span class="arithmatex">\(P\)</span>的内部。用<span class="arithmatex">\(CH(Q)\)</span>来表示<span class="arithmatex">\(Q\)</span>的凸包。</p>
<h3 id="graham扫描法">Graham扫描法<a class="headerlink" href="#graham扫描法" title="Permanent link">&para;</a></h3>
<p><code>Graham</code>扫描法通过维持一个关于候选点的栈<span class="arithmatex">\(S\)</span>来解决凸包问题。输入集合<span class="arithmatex">\(Q\)</span>中的每个点都被压入栈一次，非<span class="arithmatex">\(CH(Q)\)</span>中的顶点的点最终被弹出栈。当算法终止时，栈<span class="arithmatex">\(S\)</span>中仅包含<span class="arithmatex">\(CH(Q)\)</span>中的顶点，以逆时针的顺序出现在边界上。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">GrahamScan</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">p0</span> <span class="c1">#po为y坐标最小的点，如果有多个，选取最左边的点</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">pm</span><span class="p">)</span> <span class="c1">#根据相对于p0的极角对Q中剩余的点进行排序</span>
    <span class="k">if</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="s2">&quot;convex hull is empty&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">stack</span><span class="p">()</span>
        <span class="n">Push</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
        <span class="n">Push</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
        <span class="n">Push</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">3</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">the</span> <span class="n">angle</span> <span class="n">formed</span> <span class="n">by</span> <span class="n">points</span> <span class="n">NextToTop</span><span class="p">(</span><span class="n">S</span><span class="p">),</span><span class="n">Top</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pi</span> <span class="n">makes</span> <span class="n">a</span> <span class="n">no</span> <span class="n">left</span> <span class="n">turn</span><span class="p">:</span>
            <span class="c1">#把所有发现的不是凸包的点删去：在一个顶点处没有向左转，则弹出</span>
            <span class="n">Pop</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">Push</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span><span class="n">S</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span>
</code></pre></div></td></tr></table></div>
<h3 id="jarvis步进法">Jarvis步进法<a class="headerlink" href="#jarvis步进法" title="Permanent link">&para;</a></h3>
<p><code>Jarvis</code>步进法运用一种称为打包<code>package wrapping</code>或包装礼物<code>gift wrapping</code>的技术。</p>
<ul>
<li>把点看成是一个一个立体的柱子，凸多边形是一根围绕着所有点的线</li>
<li>线的起点为最下面的点，与Graham的开始点一样，为<span class="arithmatex">\(p_0\)</span></li>
<li>把线向右绷紧，再把线拉高一点直到碰到一个点</li>
<li>重复上面的操作，直到回到起点</li>
</ul>
<h3 id="其他算法">其他算法<a class="headerlink" href="#其他算法" title="Permanent link">&para;</a></h3>
<ul>
<li>增量法：<code>incremental method</code>，首先对点从左到右进行排序，得到一个序列<span class="arithmatex">\(&lt;p_1,p_2,...,p_n&gt;\)</span>。在第i步，根据左起第<span class="arithmatex">\(i\)</span>个点，对最左边<span class="arithmatex">\(i-1\)</span>个点的凸包<span class="arithmatex">\(CH(\{p_1,p_2,...,p_{i-1}\})\)</span>进行更新，从而形成<span class="arithmatex">\(CH(\{p_1,p_2,...,p_i\})\)</span>。</li>
<li>分治法：将由<span class="arithmatex">\(n\)</span>个点组成的几何划分为两个子集，分别包含最左边的一半和右边的一半，并对子集的凸包进行递归计算，然后利用一种巧妙的办法进行组合。</li>
<li>剪枝-搜索算法<code>prune-and-search method</code>：通过反复对其剩余点中固定数量的点，直至仅剩下凸包的上链，从而找到凸包的上部。然后再执行同样的操作来找处下链。</li>
</ul>
<h2 id="寻找最近点对">寻找最近点对<a class="headerlink" href="#寻找最近点对" title="Permanent link">&para;</a></h2>
<p>在<span class="arithmatex">\(n \geq 2\)</span>个点的集合<span class="arithmatex">\(Q\)</span>中寻找最近点对的问题。</p>
<h3 id="分治算法">分治算法<a class="headerlink" href="#分治算法" title="Permanent link">&para;</a></h3>
<p>算法每一次递归调用的输入为子集<span class="arithmatex">\(p \subseteq Q\)</span>以及数组<span class="arithmatex">\(X\)</span>和<span class="arithmatex">\(Y\)</span>，每个数组均包含输入子集<span class="arithmatex">\(P\)</span>的所有点。对数组<span class="arithmatex">\(X\)</span>中的点排序，使其<span class="arithmatex">\(x\)</span>坐标单调递增；对数组<span class="arithmatex">\(Y\)</span>中的点排序，使其<span class="arithmatex">\(y\)</span>坐标单调递增。</p>
<h3 id="分解">分解<a class="headerlink" href="#分解" title="Permanent link">&para;</a></h3>
<p>找出一条垂直线<span class="arithmatex">\(l\)</span>，它把点集<span class="arithmatex">\(P\)</span>对分为满足下列条件的两个集合<span class="arithmatex">\(P_L\)</span>和 <span class="arithmatex">\(P_R\)</span>:使得<span class="arithmatex">\(\mid P_L \mid = \lceil \mid P\mid /2 \rceil,\mid P_R \mid= \lfloor \mid P\mid /2 \rfloor\)</span>,<span class="arithmatex">\(P_L\)</span>中的所有点都在直线l上或在l的左侧，<span class="arithmatex">\(P_R\)</span>中的所有点
都在直线l上或在l的右侧。数组<span class="arithmatex">\(X\)</span>被划分为两个数组<span class="arithmatex">\(X_L\)</span>和<span class="arithmatex">\(X_R\)</span>,分别包含<span class="arithmatex">\(P_L\)</span>和<span class="arithmatex">\(P_R\)</span>中的点，并按<span class="arithmatex">\(x\)</span>坐标单调递增的顺序进行排序。类似地，将数组<span class="arithmatex">\(Y\)</span>划分为两个数组<span class="arithmatex">\(Y_L\)</span>和<span class="arithmatex">\(Y_R\)</span>分别包含<span class="arithmatex">\(P_L\)</span>和<span class="arithmatex">\(P_R\)</span>中的点，并按<span class="arithmatex">\(y\)</span>坐标单调递增的顺序进行排序</p>
<h3 id="解决">解决<a class="headerlink" href="#解决" title="Permanent link">&para;</a></h3>
<p>把<span class="arithmatex">\(P\)</span>划分为<span class="arithmatex">\(P_L\)</span>和<span class="arithmatex">\(P_R\)</span>后，再进行两次递归调用，一次找出<span class="arithmatex">\(P_L\)</span>中的最近点对，另一次
找出<span class="arithmatex">\(P_R\)</span>中的最近点对。第一次调用的输人为子集<span class="arithmatex">\(P_L\)</span>、数组<span class="arithmatex">\(X_L\)</span>和<span class="arithmatex">\(Y_L\)</span>;第二次调用的输人为子集<span class="arithmatex">\(P_R\)</span>、数组<span class="arithmatex">\(X_R\)</span>和<span class="arithmatex">\(Y_R\)</span>。令<span class="arithmatex">\(P_L\)</span>和<span class="arithmatex">\(P_R\)</span>返回的最近点对的距离分别为<span class="arithmatex">\(\delta_L\)</span>和<span class="arithmatex">\(\delta_R\)</span>，并且置<span class="arithmatex">\(\delta = \min\{\delta_L,\delta_R\}\)</span></p>
<h3 id="合并">合并<a class="headerlink" href="#合并" title="Permanent link">&para;</a></h3>
<p>最近点对要么是某次递归调用找出的距离为<span class="arithmatex">\(\delta\)</span>的点对，要么是<span class="arithmatex">\(P_L\)</span>中的一个点与<span class="arithmatex">\(P_R\)</span>中的一个点组成的点对。算法确定是否存在距离小于<span class="arithmatex">\(\delta\)</span>的一个点对，一个点位于<span class="arithmatex">\(P_L\)</span>中，另一个点位于<span class="arithmatex">\(P_R\)</span>中。注意，如果存在这样的一个点对，则点对中的两个点与直线的距离必定都在<span class="arithmatex">\(\delta\)</span>单位之内。事实上，只需要考虑<span class="arithmatex">\(\delta \times 2\delta\)</span>范围的点，且容易证明里面最多只有8个点。</p>
<p>为了找出这样的点对(如果存在)，算法要做如下工作：
1. 建立一个数组<span class="arithmatex">\(Y'\)</span>，它是把数组<span class="arithmatex">\(Y\)</span>中所有不在宽度为<span class="arithmatex">\(2 \delta\)</span>的垂直带形区域内的点去掉后所得的数组。数组<span class="arithmatex">\(Y'\)</span>与<span class="arithmatex">\(Y\)</span>一样，是按<span class="arithmatex">\(y\)</span>坐标顺序排序的。
2. 对数组<span class="arithmatex">\(Y'\)</span>中的每个点<span class="arithmatex">\(p\)</span>，算法试图找出<span class="arithmatex">\(Y'\)</span>中距离<span class="arithmatex">\(p\)</span>在<span class="arithmatex">\(\delta\)</span>单位以内的点。在<span class="arithmatex">\(Y'\)</span>中仅需考虑紧随<span class="arithmatex">\(p\)</span>后的 7 个点。算法计算出从<span class="arithmatex">\(p\)</span>到这7个点的距离，并记录下<span class="arithmatex">\(Y'\)</span>的所有点对中最近点对的距离<span class="arithmatex">\(\delta'\)</span>。
3. 如果<span class="arithmatex">\(\delta'&lt;\delta\)</span>，则垂直带形区域内的确包含比根据递归调用所找出的最近距离更近的点对,于是返回该点对及其距离<span class="arithmatex">\(\delta'\)</span>。否则，返回函数的递归调用中发现的最近点对及其距离。</p>
<h1 id="np完全性">NP完全性<a class="headerlink" href="#np完全性" title="Permanent link">&para;</a></h1>
<h2 id="概述">概述<a class="headerlink" href="#概述" title="Permanent link">&para;</a></h2>
<h3 id="判定问题与最优化问题">判定问题与最优化问题<a class="headerlink" href="#判定问题与最优化问题" title="Permanent link">&para;</a></h3>
<ul>
<li>最优化问题<code>optimization problem</code>:很多问题都是最优化问题，其中每一个可行的解都有一个关联的值，我们希望找出一个具有最佳值的可行解。</li>
<li>判定问题<code>decision pro</code>:问题的答案是简单的"是"或"否"。</li>
<li>NP完全性不适合直接应用于最优化问题，但适合用于判定问题。通常，通过对待优化的值加强一个界，就可以将一个给定的最优化问题转化为一个相关的判定问题了。事实上，所有最优化问题都可以简单转换为判定问题。</li>
</ul>
<h3 id="归约">归约<a class="headerlink" href="#归约" title="Permanent link">&para;</a></h3>
<p>我们来考虑一个判定问题<span class="arithmatex">\(A\)</span>，希望在多项式时间内解决该问题。称某一特定问题的输入为该问题的实例<code>instance</code>。现在假设有另一个不同的判定问题<span class="arithmatex">\(B\)</span>，我们知道如何在多项式时间内解决它。最后假设有一个过程，他可以将<span class="arithmatex">\(A\)</span>的任何实例<span class="arithmatex">\(\alpha\)</span>转化为<span class="arithmatex">\(B\)</span>的具有以下特征的某个实例<span class="arithmatex">\(\beta\)</span>:
- 转换操作需要多项式时间
- 两个实例的解是相同的。</p>
<p>我们称这一过程为多项式时间归约算法<code>reduction algorithm</code>,并且提供了一种在多项式时间内解决问题<span class="arithmatex">\(A\)</span>的方法：
1. 给定问题<span class="arithmatex">\(A\)</span>的实例<span class="arithmatex">\(\alpha\)</span>，利用多项式时间归约算法，将它转换为问题<span class="arithmatex">\(B\)</span>的一个实例<span class="arithmatex">\(\beta\)</span>
2. 在实例<span class="arithmatex">\(\beta\)</span>上，运行<span class="arithmatex">\(B\)</span>的多项式时间判定算法
3. 将<span class="arithmatex">\(\beta\)</span>的解作为<span class="arithmatex">\(\alpha\)</span>的解</p>
<h2 id="多项式时间">多项式时间<a class="headerlink" href="#多项式时间" title="Permanent link">&para;</a></h2>
<p>形式化地定义一下多项式时间可解问题，为此先定义以下相关内容。</p>
<h3 id="抽象问题">抽象问题<a class="headerlink" href="#抽象问题" title="Permanent link">&para;</a></h3>
<p>定义<strong>抽象问题</strong><span class="arithmatex">\(Q\)</span>为在问题<strong>实例</strong>集合<span class="arithmatex">\(I\)</span>和问题<strong>解</strong>集合<span class="arithmatex">\(S\)</span>上的一个二元关系。NP完全性理论把注意力集中在判定问题上，于是我们把抽象问题的判定问题看做是从实例集<span class="arithmatex">\(I\)</span>映射到解集<span class="arithmatex">\(\{0,1\}\)</span>上的一个函数。</p>
<h3 id="编码">编码<a class="headerlink" href="#编码" title="Permanent link">&para;</a></h3>
<ul>
<li>抽象对象集合<span class="arithmatex">\(S\)</span>的编码是从<span class="arithmatex">\(S\)</span>到二进制串集合的映射<span class="arithmatex">\(e\)</span>。</li>
<li>我们把以二进制串集合为实例集的问题称为<strong>具体问题</strong>。</li>
<li>因此，如果对于某个常数<span class="arithmatex">\(k\)</span>，存在一个能在<span class="arithmatex">\(O(n^k)\)</span>时间内求解出某具体问题的算法，就说该具体问题是<strong>多项式时间可解的</strong>。</li>
<li>现在形式化地定义<strong>复杂类P为在多项时间内可解的具体判定问题的集合</strong>。
  对一个函数<span class="arithmatex">\(f:\{0,1\}^* \rightarrow \{0,1\}^*\)</span>,如果存在一个多项式时间的算法<span class="arithmatex">\(A\)</span>,它对任意给定的输入<span class="arithmatex">\(x \in \{0,1\}^*\)</span>,都能产生输出<span class="arithmatex">\(f(x)\)</span>,则称该函数是一个<strong>多项式时间可计算的</strong>函数。</li>
<li>对某个问题实例<span class="arithmatex">\(I\)</span>,如果存在两个多项式时间可计算的函数<span class="arithmatex">\(f_{12}\)</span>和<span class="arithmatex">\(f_{21}\)</span>满足对任意<span class="arithmatex">\(i\in I\)</span>,有<span class="arithmatex">\(f_{12}(e_1(i))=e_2(i)\)</span>,且<span class="arithmatex">\(f_{12}(e_2(i))=e_1(i)\)</span>，我们就说这两种编码<span class="arithmatex">\(e_1\)</span>和<span class="arithmatex">\(e_2\)</span>是<strong>多项式相关的</strong>。</li>
<li>如果某一抽象问题的两种编码是多项式相关的，可以证明，<strong>该问题本身是否是多项式时间可解与选用哪一种编码无关</strong>。
  为了方便，我们一般假设所有问题实例都是采用<strong>标准编码</strong>的二进制串。对于一个实例图<span class="arithmatex">\(G\)</span>，它的标准编码记作<span class="arithmatex">\(&lt;G&gt;\)</span>。</li>
</ul>
<h3 id="形式语言体系">形式语言体系<a class="headerlink" href="#形式语言体系" title="Permanent link">&para;</a></h3>
<p><strong>字母表</strong><span class="arithmatex">\(\sum\)</span>是符号的有限集合。字母表<span class="arithmatex">\(\sum\)</span>上的<strong>语言</strong><span class="arithmatex">\(L\)</span>是由表中符号组成的串的任意集合。我们用<span class="arithmatex">\(\epsilon\)</span>表示空串，用<span class="arithmatex">\(\varnothing\)</span>表示空语言，<span class="arithmatex">\(\sum\)</span>上所有串构成的语言表示为<span class="arithmatex">\(∑^*\)</span>。<span class="arithmatex">\(\sum\)</span>上每个语言<span class="arithmatex">\(L\)</span>都是<span class="arithmatex">\(∑^*\)</span>的一个子集。
- 我们把多种运算作用于语言。集合轮中的运算，其直接来自集合轮定义。
- 定义<span class="arithmatex">\(L\)</span>的补为<span class="arithmatex">\(\overline L=∑^*-L\)</span>。
- 两种语言<span class="arithmatex">\(L_1\)</span>和<span class="arithmatex">\(L_2\)</span>的连接<span class="arithmatex">\(L_1L_2\)</span>是语言<span class="arithmatex">\(L=\{x_1x_2:x_1 \in L_1 且 x_2 \in L_2\}\)</span>。
- 语言L的闭包为<span class="arithmatex">\(L^*=\{\epsilon\} \cup L \cup L^2 \cup L^3 \cup \cdots\)</span>,其中<span class="arithmatex">\(L^k\)</span>是L与其自身进行k次并置运算后得到的语言。</p>
<p>任何判定问题<span class="arithmatex">\(Q\)</span>的实例集即集合<span class="arithmatex">\(∑^*\)</span>，其中<span class="arithmatex">\(\sum=\{0,1\}\)</span>。因为<span class="arithmatex">\(Q\)</span>完全是由解为<code>1</code>的问题实例来描述的，因而可以把<span class="arithmatex">\(Q\)</span>看做是定义在<span class="arithmatex">\(\sum=\{0,1\}\)</span>的一个语言<span class="arithmatex">\(L\)</span>，其中</p>
<div class="arithmatex">\[
L=\{x\in \Sum^*:Q(x)=1\}
\]</div>
<p>形式语言体系可以用来表示判定问题与求解这些问题的算法之间的关系。
- 如果对给定输入<span class="arithmatex">\(x\)</span>,算法输出<span class="arithmatex">\(A(x)=1\)</span>,我们就说算法A<strong>接受</strong>串<span class="arithmatex">\(x\in \{0,1\}^*\)</span>。
- 被算法<span class="arithmatex">\(A\)</span>接受的语言是串的集合<span class="arithmatex">\(L=\{x\in\{0,1\}^*:A(x)=1\}\)</span>，即为算法所接受的串的集合。
- 如果<span class="arithmatex">\(A(x)=0\)</span>,则算法<span class="arithmatex">\(A\)</span><strong>拒绝</strong>串<span class="arithmatex">\(x\)</span>。
- 即使语言<span class="arithmatex">\(L\)</span>被算法<span class="arithmatex">\(A\)</span>所接受，该算法也不一定会拒绝输入一个串<span class="arithmatex">\(x \in L\)</span>。例如，某一算法可能会永远循环下去。如果<span class="arithmatex">\(L\)</span>中每个二进制串只是被算法<span class="arithmatex">\(A\)</span>接受或拒绝，则称语言<span class="arithmatex">\(L\)</span>由算法<span class="arithmatex">\(A\)</span>判定。
- 要接受一个语言，算法只需要根据提供的L中的字符串给出一个答案，但要判定某一语言，算法必须正确的接受或拒绝<span class="arithmatex">\(\{0,1\}^*\)</span>中的每一个串。
- 对于一些算法，存在接受算法，但不存在判定算法。</p>
<p>复杂类<span class="arithmatex">\(P\)</span>的另外一种定义</p>
<div class="arithmatex">\[
P=\{L \subseteq\{0,1\}^*:存在一个算法A，可以在多项式时间内判定L\}
\]</div>
<div class="arithmatex">\[
P=\{L:L能被一个多项式时间所接受\}
\]</div>
<h2 id="多项式时间的验证">多项式时间的验证<a class="headerlink" href="#多项式时间的验证" title="Permanent link">&para;</a></h2>
<h3 id="验证算法">验证算法<a class="headerlink" href="#验证算法" title="Permanent link">&para;</a></h3>
<p>我们定义验证算法为含有两个自变量的算法<span class="arithmatex">\(A\)</span>，其中一个自变量是普通输入串<span class="arithmatex">\(x\)</span>，另一个是称为"证书"的二进制<span class="arithmatex">\(y\)</span>。如果存在一个整数<span class="arithmatex">\(y\)</span>满足<span class="arithmatex">\(A(x,y)=1\)</span>，则该含两个自变量的算法<span class="arithmatex">\(A\)</span>验证了输入串<span class="arithmatex">\(x\)</span>。有一个验证算法<span class="arithmatex">\(A\)</span>所验证的语言是：</p>
<div class="arithmatex">\[
L=\{x\in \{0,1\}^*:存在y\in \{0,1\}^*,满足A(x,y)=1\}
\]</div>
<p>从直观上来说，如果对任意串<span class="arithmatex">\(x\in L\)</span>,都存在一个证书<span class="arithmatex">\(y\)</span>,且算法<span class="arithmatex">\(A\)</span>可以用<span class="arithmatex">\(y\)</span>来证明<span class="arithmatex">\(x\in L\)</span>,则算法<span class="arithmatex">\(A\)</span>就验证了语言<span class="arithmatex">\(L\)</span>。</p>
<h3 id="复杂类np">复杂类NP<a class="headerlink" href="#复杂类np" title="Permanent link">&para;</a></h3>
<ul>
<li>复杂类<span class="arithmatex">\(NP\)</span>是能够被一个多项式时间算法验证的语言类。更准确地说，一个语言<span class="arithmatex">\(L\)</span>属于<span class="arithmatex">\(NP\)</span>，当且仅当存在一个两输入的多项式时间算法<span class="arithmatex">\(A\)</span>和常数<span class="arithmatex">\(c\)</span>，满足：</li>
</ul>
<div class="arithmatex">\[
    L=\{x\in\{0,1\}^*:存在一个证书y，\mid y \mid =O(\mid c \mid ^c),满足A(x,y)=1\}
\]</div>
<p>我们说算法<span class="arithmatex">\(A\)</span>在多项式时间内验证了语言<span class="arithmatex">\(L\)</span>。
- 复杂类<span class="arithmatex">\(co-NP\)</span>为满足<span class="arithmatex">\(\overline L \in NP\)</span>的语言<span class="arithmatex">\(L\)</span>构成的集合。</p>
<h2 id="np完全性与可归约性">NP完全性与可归约性<a class="headerlink" href="#np完全性与可归约性" title="Permanent link">&para;</a></h2>
<p><span class="arithmatex">\(NP\)</span>完全性问题是<span class="arithmatex">\(NP\)</span>中最难的语言，如果任何一个<span class="arithmatex">\(NP\)</span>完全性问题能在多项式时间内得到解决，那么NP中的每一个问题都存在一个多项式时间解，即<span class="arithmatex">\(NP=P\)</span>。下面给出比较各语言难度的方式</p>
<h3 id="可归约性">可归约性<a class="headerlink" href="#可归约性" title="Permanent link">&para;</a></h3>
<p>从直觉上来说，问题<span class="arithmatex">\(Q\)</span>可以归纳为另一个问题<span class="arithmatex">\(Q'\)</span>。从某种意义上来说，<span class="arithmatex">\(Q\)</span>并不比<span class="arithmatex">\(Q'\)</span>更难解决。
我们说语言<span class="arithmatex">\(L_1\)</span>在多项式时间内可以归纳为语言<span class="arithmatex">\(L_2\)</span>,记作<span class="arithmatex">\(L_1 \leq_p L_2\)</span>,如果存在一个多项式时间可计算的函数<span class="arithmatex">\(f:\{0,1\}^* \rightarrow \{0,1\}^*\)</span>,满足对所有的<span class="arithmatex">\(x\in \{0,1\}^*\)</span>，</p>
<div class="arithmatex">\[
x \in L_1 当且仅当f(x) = L_2
\]</div>
<p>则称函数<span class="arithmatex">\(f\)</span>为<strong>归约函数</strong>，计算<span class="arithmatex">\(f\)</span>的多项式时间算法<span class="arithmatex">\(F\)</span>称为<strong>归约算法</strong>。</p>
<p>如果<span class="arithmatex">\(L_1,L_2 \subseteq \{0,1\}^*\)</span>是满足<span class="arithmatex">\(L_1 \leq_P L_2\)</span>的语言，则<span class="arithmatex">\(L_2 \in P\)</span>蕴含着<span class="arithmatex">\(L_1 \in P\)</span></p>
<h3 id="np完全性_1">NP完全性<a class="headerlink" href="#np完全性_1" title="Permanent link">&para;</a></h3>
<p>语言<span class="arithmatex">\(L \subseteq \{0,1\}^*\)</span>是NP完全的，如果：
1. <span class="arithmatex">\(L \in NP\)</span>
2. 对每一个<span class="arithmatex">\(L' \in NP_2\)</span>，有<span class="arithmatex">\(L' \leq_P L\)</span>。</p>
<p>如果一种语言<span class="arithmatex">\(L\)</span>满足性质<code>2</code>，但不一定满足性质<code>1</code>，则称<span class="arithmatex">\(L\)</span>是<strong>NP难度</strong><code>NP-hard</code>的。同时我们定义<span class="arithmatex">\(NPC\)</span>为<span class="arithmatex">\(NP\)</span>完全语言类。</p>
<p><span class="arithmatex">\(NP\)</span>完全性是判定<span class="arithmatex">\(N=?NP\)</span>的关键:如果任何<span class="arithmatex">\(NP\)</span>完全问题是多项式时间可求解的，则<span class="arithmatex">\(P=NP\)</span>。等价的，如果存在某一<span class="arithmatex">\(NP\)</span>中的问题不是多项式可求解的，则所有<span class="arithmatex">\(NP\)</span>完全问题都不是多项式时间可求解的</p>
<h2 id="np完全性的证明">NP完全性的证明<a class="headerlink" href="#np完全性的证明" title="Permanent link">&para;</a></h2>
<h3 id="依据">依据<a class="headerlink" href="#依据" title="Permanent link">&para;</a></h3>
<p>如果语言<span class="arithmatex">\(L\)</span>是一种满足对任意<span class="arithmatex">\(L' \in NPC\)</span>都有<span class="arithmatex">\(L' \leq_P L\)</span>的语言，则<span class="arithmatex">\(L\)</span>是<span class="arithmatex">\(NP\)</span>难度的。此外，如果<span class="arithmatex">\(L \in NP\)</span>,则<span class="arithmatex">\(L \in NPC\)</span>。</p>
<h3 id="证明方法">证明方法<a class="headerlink" href="#证明方法" title="Permanent link">&para;</a></h3>
<ol>
<li>证明<span class="arithmatex">\(L \in NP\)</span></li>
<li>选取一种已知的<span class="arithmatex">\(NP\)</span>完全语言<span class="arithmatex">\(L'\)</span></li>
<li>描述一种可计算函数<span class="arithmatex">\(f(x)\)</span>的算法，其中<span class="arithmatex">\(f\)</span>可将<span class="arithmatex">\(L'\)</span>中每一个实例<span class="arithmatex">\(x \in \{0,1\}^*\)</span>映射为<span class="arithmatex">\(L\)</span>中的实例<span class="arithmatex">\(f(x)\)</span></li>
<li>证明函数<span class="arithmatex">\(f\)</span>满足<span class="arithmatex">\(x \in L'\)</span>当且仅当对于所有的<span class="arithmatex">\(x \in \{0,1\}^*\)</span>都有<span class="arithmatex">\(f(x) \in L\)</span></li>
<li>证明计算函数<span class="arithmatex">\(f\)</span>的算法具有多项式运行时间</li>
</ol>
<h2 id="np完全问题">NP完全问题<a class="headerlink" href="#np完全问题" title="Permanent link">&para;</a></h2>
<ul>
<li>电路可满足性</li>
<li>公式可满足性</li>
<li>3-CNF可满足性</li>
<li>团问题</li>
<li>顶点覆盖问题</li>
<li>哈密顿回路问题</li>
<li>旅行商问题</li>
<li>子集和问题</li>
</ul>
<h1 id="近似算法">近似算法<a class="headerlink" href="#近似算法" title="Permanent link">&para;</a></h1>
<p>虽然<span class="arithmatex">\(NP\)</span>完全问题暂时不能在多项式时间内得到最优解，但解决<span class="arithmatex">\(NP\)</span>完全问题方法并不是没有
- 如果实际输入规模较小，则用指数级运算时间的算法就可以很好的解决问题
- 对于一些能在多项式时间内解决的特殊情况，可以把它们单独列出来求解
- 可以寻找一些能够在多项式时间内得到近似最优解的方法，即近似算法<code>approximation algorithm</code></p>
<h2 id="近似算法的性能比">近似算法的性能比<a class="headerlink" href="#近似算法的性能比" title="Permanent link">&para;</a></h2>
<ul>
<li>如果对规模为<span class="arithmatex">\(n\)</span>的任意输入，近似算法所产生的近似解的代价C与最优解的代价<span class="arithmatex">\(C^*\)</span>只差一个因子<span class="arithmatex">\(\rho(n)\)</span>:</li>
</ul>
<div class="arithmatex">\[
\max(\frac{C}{C^*},\frac{C^*}{C}) \leq \rho(n)
\]</div>
<p>则称该近似算法有<strong>近似比</strong><span class="arithmatex">\(\rho(n)\)</span>。如果一个算法的近似比达到<span class="arithmatex">\(\rho(n)\)</span>,则称该算法为<span class="arithmatex">\(\rho(n)\)</span>近似算法。<span class="arithmatex">\(\rho(n) \geq 1\)</span>
- 一个最优化问题的<strong>近似模式</strong><code>approximation scheme</code>就是这样一种近似算法，它的输入除了该问题的实例外，还有一个值<span class="arithmatex">\(\epsilon&gt;0\)</span>,使得对任何固定的<span class="arithmatex">\(\epsilon\)</span>，该模式是一个<span class="arithmatex">\((1+\epsilon)\)</span>近似算法。对一个近似模式来说，如果对于任何固定的<span class="arithmatex">\(\epsilon&gt;0\)</span>,该模式都以其输入实例规模<span class="arithmatex">\(n\)</span>的多项式时间运行，则称此模式为<strong>多项式时间近似模式</strong>。
- 对一个近似模式来说，如果其运行时间表达式即为<span class="arithmatex">\(\frac 1 \epsilon\)</span>的多项式，又为输入实例规模n的多项式，则称其为<strong>完全多项式时间近似模式</strong>。</p>
<h2 id="近似算法举例">近似算法举例<a class="headerlink" href="#近似算法举例" title="Permanent link">&para;</a></h2>
<ul>
<li>顶点覆盖问题</li>
<li>旅行商问题</li>
<li>集合覆盖问题</li>
<li>子集和问题</li>
</ul>
<h3 id="近似比的证明">近似比的证明<a class="headerlink" href="#近似比的证明" title="Permanent link">&para;</a></h3>
<p>通过将近似算法返回结果的规模与最优解的下界进行比较，得到近似比。</p>


  



 
 
 
<hr><blockquote class="page-copyright">
  <span><i class="md-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m22.7 19-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4Z"/></svg></i>本页面最近更新：</span><span class="facts_modified"></span>，<a class="edit_history">更新历史</a><br>
  <span><i class="md-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg></i>发现错误？想一起完善？ <a href="mailto:jx1661463472@qq.com" title="发送邮件给我">联系我</a><br>
  <span><i class="md-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16 17v2H2v-2s0-4 7-4 7 4 7 4m-3.5-9.5A3.5 3.5 0 1 0 9 11a3.5 3.5 0 0 0 3.5-3.5m3.44 5.5A5.32 5.32 0 0 1 18 17v2h4v-2s0-3.63-6.06-4M15 4a3.39 3.39 0 0 0-1.93.59 5 5 0 0 1 0 5.82A3.39 3.39 0 0 0 15 11a3.5 3.5 0 0 0 0-7Z"/></svg></i>本页面贡献者：</span><span class="page_contributors">Jacy</span><br>
  <span><i class="md-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10.08 10.86c.05-.33.16-.62.3-.86.3-.56.81-.85 1.5-.86.45 0 .86.2 1.15.49.28.31.47.74.47 1.17h1.8c-.02-.47-.11-.9-.3-1.3-.15-.38-.38-.72-.68-1-1.45-1.34-4.14-1.15-5.37.37-1.29 1.67-1.32 4.59-.01 6.26 1.21 1.49 3.86 1.7 5.3.37.31-.25.56-.56.76-.92.16-.36.27-.74.28-1.15H13.5c0 .21-.07.4-.16.57-.09.19-.21.34-.34.47-.33.26-.72.4-1.14.4-.36-.01-.66-.08-.89-.23a1.41 1.41 0 0 1-.59-.64c-.5-.9-.42-2.15-.3-3.14M12 2C6.5 2 2 6.5 2 12c.53 13.27 19.5 13.26 20 0 0-5.5-4.5-10-10-10m0 18c-4.41 0-8-3.59-8-8 .44-10.61 15.56-10.61 16 0 0 4.41-3.59 8-8 8Z"/></svg></i>本页面的全部内容在 <strong><a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a></strong> 协议之条款下提供，附加条款亦可能应用</span>
</blockquote>


<div id="__comments" class="giscus" data-no-instant></div>
<div id="__comments_script"></div>
<script>var comments=document.createElement("script"),commentsTheme="slate"===document.body.dataset.mdColorScheme?"dark":"light";Object.entries({async:!0,src:"https://giscus.app/client.js",crossOrigin:"anonymous","data-repo":"Jacy/gitment","data-repo-id":"MDEwOlJlcG9zaXRvcnkxNDQzODg5NjU=","data-category":"评论","data-category-id":"DIC_kwDOCJszZc4CS54y","data-mapping":"specific","data-term":"绪论","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":commentsTheme,"data-lang":"zh-CN","data-loading":"lazy"}).forEach(e=>comments.setAttribute(e[0],e[1])),document.getElementById("__comments_script").replaceWith(comments)</script>

                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <script>function scrollFunction(){20<document.body.scrollTop||20<document.documentElement.scrollTop?document.getElementById("myBtn").style.display="block":document.getElementById("myBtn").style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}window.onscroll=function(){scrollFunction()}</script>
<button onclick="topFunction()" id="myBtn" class="data-tip-left" data-tip="回到顶部">
  <svg class="Zi Zi--BackToTop data-tip-left" data-tip="回到顶部" fill="currentColor" viewBox="0 0 24 24" width="24" height="24">
    <path d="M16.036 19.59a1 1 0 0 1-.997.995H9.032a.996.996 0 0 1-.997-.996v-7.005H5.03c-1.1 0-1.36-.633-.578-1.416L11.33 4.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.005z"></path>
  </svg>
</button>
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 - 2025 Jacy
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
      <div id="miitbeian"></div>
    </a>
  
</div>

<div style="float:right" class="build_date_utc">
  <a href="https://github.com/Jacy/Jacy">
    最近更新：, 2024-04-12
  </a>
</div>
<script>"Jacy.com"==window.location.hostname&&(document.getElementById("miitbeian").innerHTML='<a href="http://beian.miit.gov.cn/">黑ICP备19005132号-2</a>'),console.log("%c Jacy %c  %c","background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff","background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff","background:transparent"),console.log("少年，恭喜你囍提彩蛋，我们在做一些 OI 相关的有趣的事情，如果您对此感兴趣，欢迎访问 https://join-us.Jacy.org")</script>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.instant"], "search": "../../assets/javascripts/workers/search.8e7a41fd.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.561f57c7.min.js"></script>
      
        <script src="../../_static/js/math-csr.js?math-csr"></script>
      
        <script src="../../assets/vendor/mathjax/es5/tex-mml-chtml.js?math-csr"></script>
      
      <script>"use strict";"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js",{scope:"/"}).then(function(e){console.log("PWA Registration succeeded. Scope is "+e.scope)}).catch(function(e){console.log("PWA Registration failed with "+e)})</script>
    
    
  </body>
</html>